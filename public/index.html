<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindOS - Your Personal AI Feed</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
            height: 100vh;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        /* =========================
           LOGIN SCREEN 
        ========================= */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .login-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .logo {
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 2rem;
            color: white;
            font-size: 2rem;
        }

        .login-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .login-subtitle {
            color: #666;
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 2px solid #e0e6ff;
            border-radius: 12px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-bottom: 1rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .switch-mode {
            color: #667eea;
            cursor: pointer;
            text-decoration: underline;
        }

        /* =========================
           NEVER-ENDING FEED LAYOUT
        ========================= */
        .feed-container {
            display: none;
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
        }

        /* Fixed Header */
        .feed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .mindos-logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
        }

        .user-info h3 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .user-info p {
            font-size: 0.9rem;
            color: #888;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .header-btn {
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .header-btn.add-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        /* IMPROVED: Never-ending Feed Scroll Container */
        .feed-scroll {
            height: 100vh;
            width: 100%;
            overflow-y: scroll;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-top: 80px;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        .feed-scroll::-webkit-scrollbar {
            display: none;
        }

        /* IMPROVED: Flexible Feed Cards */
        .feed-card {
            min-height: calc(100vh - 80px);
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f4c75 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 2px;
        }

        .feed-card:nth-child(even) {
            background: linear-gradient(135deg, #2d1b69 0%, #11998e 50%, #38ef7d 100%);
        }

        .feed-card:nth-child(3n) {
            background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
        }

        .feed-card.compact {
            min-height: 60vh;
        }

        .feed-card.expanded {
            min-height: calc(100vh - 80px);
        }

        /* Card Content Area */
        .card-content-area {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .card-type-badge {
            position: absolute;
            top: 2rem;
            left: 2rem;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-priority {
            position: absolute;
            top: 2rem;
            right: 2rem;
            font-size: 1.5rem;
            color: #ffd700;
        }

        .card-brain-logo {
            position: absolute;
            top: 50%;
            left: 2rem;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        .card-brain-logo:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
        }

        .card-main-content {
            text-align: center;
            max-width: 600px;
            margin: 0 auto;
        }

        .card-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1.2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .card-description {
            font-size: 1.2rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
        }

        .card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Social Media Actions */
        .card-actions {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .action-btn.completed {
            background: #00d084;
            color: white;
        }

        .action-btn.ai-chat {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        /* NEW: Scroll Position Indicator */
        .scroll-indicator {
            position: fixed;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 900;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 1rem 0.5rem;
        }

        .scroll-indicator .current-item {
            font-size: 0.8rem;
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .scroll-indicator .total-items {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.5rem;
        }

        .scroll-progress {
            width: 4px;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            position: relative;
        }

        .scroll-progress-fill {
            width: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
            transition: height 0.3s ease;
            height: 0%;
        }

        /* NEW: End of Feed Message */
        .end-of-feed {
            min-height: 60vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2c1810 0%, #8b4513 100%);
            text-align: center;
            padding: 4rem 2rem;
        }

        .end-of-feed .brain-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            margin-bottom: 2rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .end-of-feed h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

        .end-of-feed p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.8);
            max-width: 500px;
            line-height: 1.6;
        }

        .end-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .end-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .end-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        /* Loading more items indicator */
        .loading-more {
            padding: 2rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* =========================
           EDIT/QUICK ADD OVERLAY - UNIFIED STYLING
        ========================= */
        .edit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 2rem;
        }

        .edit-overlay.show {
            display: flex;
        }

        .edit-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .edit-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .edit-input {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .edit-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .edit-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        /* ENHANCED: Improved select dropdown styling for better visibility */
        .edit-input select {
            background: rgba(0, 0, 0, 0.8) !important;
            color: white !important;
            border: 1px solid rgba(255, 255, 255, 0.3);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1rem;
            padding-right: 3rem;
        }

        .edit-input select option {
            background: rgba(0, 0, 0, 0.95) !important;
            color: white !important;
            padding: 0.5rem;
            border: none;
        }

        .edit-input select option:hover,
        .edit-input select option:checked,
        .edit-input select option:focus {
            background: rgba(102, 126, 234, 0.8) !important;
            color: white !important;
        }

        .edit-input select option[value=""] {
            color: rgba(255, 255, 255, 0.7) !important;
            font-style: italic;
        }

        .edit-input select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
            background: rgba(0, 0, 0, 0.9) !important;
        }

        /* UNIFIED: Core fields styling for both add and edit */
        .core-fields {
            margin-bottom: 2rem;
        }

        .optional-fields {
            margin-bottom: 1rem;
        }

        .optional-fields.collapsed {
            display: none;
        }

        .field-controls {
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .field-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 0.5rem;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .field-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .available-fields {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            display: none;
        }

        .available-fields.show {
            display: block;
        }

        .field-tag {
            display: inline-block;
            background: rgba(102, 126, 234, 0.3);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            margin: 0.2rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .field-tag:hover {
            background: rgba(102, 126, 234, 0.5);
        }

        .field-tag.added {
            background: rgba(76, 175, 80, 0.3);
        }

        .field-remove-btn {
            background: rgba(244, 67, 54, 0.3);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            margin-left: 0.5rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .field-remove-btn:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .edit-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .edit-btn {
            flex: 1;
            padding: 1rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .edit-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .edit-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Data validation feedback */
        .validation-error {
            border-color: #f44336 !important;
            box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.3) !important;
        }

        .validation-message {
            color: #f44336;
            font-size: 0.8rem;
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
        }

        /* =========================
           AI CHAT INTERFACE
        ========================= */
        .ai-chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            z-index: 3000;
        }

        .ai-chat-overlay.show {
            display: flex;
            flex-direction: column;
        }

        .ai-chat-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ai-chat-title {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .ai-chat-title .brain-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
        }

        .ai-chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .ai-message {
            display: flex;
            gap: 1rem;
            max-width: 80%;
        }

        .ai-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .ai-message.assistant {
            align-self: flex-start;
        }

        .ai-message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .ai-message.user .ai-message-avatar {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .ai-message.assistant .ai-message-avatar {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .ai-message-content {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1rem;
            word-wrap: break-word;
        }

        .ai-message.user .ai-message-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .ai-chat-input-container {
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ai-chat-input-wrapper {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .ai-chat-input {
            flex: 1;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            resize: none;
            min-height: 50px;
            max-height: 150px;
        }

        .ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .ai-chat-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .ai-chat-send {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.1);
        }

        .ai-chat-send:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Loading States */
        .loading {
            position: relative;
            color: transparent !important;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: rgba(255, 255, 255, 0.8);
            animation: spin 1s linear infinite;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            color: white;
            padding: 1rem 2rem;
            border-radius: 30px;
            font-weight: 600;
            z-index: 3000;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .feed-header {
                padding: 0 1rem;
            }
            
            .card-title {
                font-size: 2rem;
            }
            
            .card-description {
                font-size: 1rem;
            }
            
            .card-content-area {
                padding: 1.5rem;
            }
            
            .card-actions {
                bottom: 1rem;
                right: 1rem;
            }
            
            .action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .card-brain-logo {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }

            .ai-chat-messages {
                padding: 1rem;
            }

            .ai-chat-input-container {
                padding: 1rem;
            }

            .scroll-indicator {
                right: 0.5rem;
                padding: 0.5rem 0.3rem;
            }

            .edit-input select option {
                font-size: 16px;
                padding: 0.75rem 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="login-card">
            <div class="logo">
                <i class="fas fa-brain"></i>
            </div>
            <h1 class="login-title">MindOS</h1>
            <p class="login-subtitle">Your Personal AI Assistant</p>
            
            <!-- Login Form -->
            <form id="loginForm" style="display: block;">
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit" class="btn" id="loginBtn">
                    <i class="fas fa-sign-in-alt"></i> Sign In
                </button>
                <p>Don't have an account? <span class="switch-mode" onclick="showRegister()">Sign up</span></p>
            </form>

            <!-- Register Form -->
            <form id="registerForm" style="display: none;">
                <div class="form-group">
                    <label for="regUsername">Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label for="regEmail">Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label for="regPassword">Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button type="submit" class="btn" id="registerBtn">
                    <i class="fas fa-user-plus"></i> Create Account
                </button>
                <p>Already have an account? <span class="switch-mode" onclick="showLogin()">Sign in</span></p>
            </form>
        </div>
    </div>

    <!-- Never-Ending Feed -->
    <div id="feedContainer" class="feed-container">
        <!-- Fixed Header -->
        <div class="feed-header">
            <div class="header-left">
                <div class="mindos-logo">
                    <i class="fas fa-brain"></i>
                </div>
                <div class="user-info">
                    <h3 id="feedUserName">Loading...</h3>
                    <p id="feedItemCount">0 items in feed</p>
                </div>
            </div>
            <div class="header-actions">
                <button class="header-btn add-btn" onclick="showAddItem()" title="Add New Item">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="header-btn" onclick="refreshFeed()" title="Refresh Feed">
                    <i class="fas fa-refresh"></i>
                </button>
                <button class="header-btn" onclick="scrollToTop()" title="Back to Top">
                    <i class="fas fa-arrow-up"></i>
                </button>
                <button class="header-btn" onclick="showProfile()" title="Profile">
                    <i class="fas fa-user"></i>
                </button>
                <button class="header-btn" onclick="logout()" title="Logout">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
            </div>
        </div>

        <!-- Scrollable Feed -->
        <div class="feed-scroll" id="feedScroll">
            <!-- Feed cards will be dynamically inserted here -->
        </div>

        <!-- Scroll Position Indicator -->
        <div class="scroll-indicator" id="scrollIndicator">
            <div class="current-item" id="currentItemNumber">1</div>
            <div class="scroll-progress">
                <div class="scroll-progress-fill" id="scrollProgressFill"></div>
            </div>
            <div class="total-items" id="totalItemsCount">0</div>
        </div>
    </div>

    <!-- UNIFIED Edit/Add Overlay -->
    <div id="editOverlay" class="edit-overlay">
        <div class="edit-card">
            <h2 class="edit-title" id="editTitle">Edit Item</h2>
            
            <!-- Core Fields - Used for both Add and Edit -->
            <div id="coreFields" class="core-fields">
                <!-- Essential fields will be inserted here -->
            </div>
            
            <!-- Field Management Controls - Hidden for Add mode -->
            <div class="field-controls" id="fieldControls">
                <button type="button" class="field-control-btn" onclick="toggleOptionalFields()">
                    <i class="fas fa-plus"></i> Add Fields
                </button>
                <button type="button" class="field-control-btn" onclick="toggleAvailableFields()">
                    <i class="fas fa-list"></i> Browse Fields
                </button>
            </div>
            
            <!-- Available Fields Picker -->
            <div id="availableFields" class="available-fields">
                <p style="margin-bottom: 1rem; font-size: 0.9rem;">Click to add fields:</p>
                <div id="fieldTags">
                    <!-- Field tags will be inserted here -->
                </div>
            </div>
            
            <!-- Optional Fields -->
            <div id="optionalFields" class="optional-fields collapsed">
                <!-- Additional fields will be inserted here -->
            </div>
            
            <div class="edit-actions">
                <button class="edit-btn secondary" onclick="closeEdit()">Cancel</button>
                <button class="edit-btn primary" onclick="saveEdit()" id="saveEditBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- AI Chat Overlay -->
    <div id="aiChatOverlay" class="ai-chat-overlay">
        <div class="ai-chat-header">
            <div class="ai-chat-title">
                <div class="brain-icon">
                    <i class="fas fa-brain"></i>
                </div>
                <div>
                    <h3 id="aiChatItemTitle">Chat with MindOS AI</h3>
                    <p id="aiChatItemType">About this item</p>
                </div>
            </div>
            <button class="header-btn" onclick="closeAIChat()" title="Close Chat">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="ai-chat-container">
            <div class="ai-chat-messages" id="aiChatMessages">
                <!-- Chat messages will be inserted here -->
            </div>
            
            <div class="ai-chat-input-container">
                <div class="ai-chat-input-wrapper">
                    <textarea 
                        id="aiChatInput" 
                        class="ai-chat-input" 
                        placeholder="Ask MindOS about this item, request changes, or get help..."
                        rows="1"
                    ></textarea>
                    <button id="aiChatSend" class="ai-chat-send" onclick="sendAIMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global State
        let currentUser = null;
        let authToken = localStorage.getItem('mindos_token');
        let feedItems = [];
        let currentEditItem = null;
        let currentAIItem = null;
        let aiChatHistory = [];
        let databaseSchema = null;
        let activeOptionalFields = new Set();
        let debugMode = false;
        let isAddMode = false; // UNIFIED: Replace isQuickAdd with isAddMode
        
        // NEW: Never-ending feed state
        let currentScrollPosition = 0;
        let isLoadingMore = false;
        let hasMoreItems = true;
        let currentPage = 0;
        const ITEMS_PER_PAGE = 10;

        // UPDATED: Unified field configuration
        const CORE_FIELDS = ['content', 'type', 'status', 'priority'];
        const BASIC_ADD_FIELDS = ['type', 'content', 'priority', 'due', 'status'];

        // ===== DROPDOWN VISIBILITY FIX =====
        // Multi-stage fix for dropdown color and visibility issues
        
        function fixDropdownVisibility() {
            console.log('ðŸ”§ Fixing dropdown visibility...');
            
            // Find all select elements in the edit overlay
            const selects = document.querySelectorAll('.edit-input select, #editOverlay select, .edit-overlay select');
            
            console.log(`Found ${selects.length} select elements to fix`);
            
            selects.forEach((select, index) => {
                console.log(`Fixing select ${index + 1}:`, select.id || 'unnamed');
                
                // Force dark background directly via JavaScript (this will override CSS)
                select.style.setProperty('background', 'rgba(0, 0, 0, 0.8)', 'important');
                select.style.setProperty('background-color', '#1a1a1a', 'important');
                select.style.setProperty('color', '#ffffff', 'important');
                select.style.setProperty('border', '2px solid #667eea', 'important');
                select.style.setProperty('font-size', '16px', 'important');
                
                // Also fix all option elements
                const options = select.querySelectorAll('option');
                options.forEach((option, optIndex) => {
                    option.style.setProperty('background-color', '#1a1a1a', 'important');
                    option.style.setProperty('background', '#1a1a1a', 'important');
                    option.style.setProperty('color', '#ffffff', 'important');
                    console.log(`  Fixed option ${optIndex + 1}: ${option.textContent}`);
                });
                
                // Add event listeners for better feedback
                select.addEventListener('focus', function() {
                    this.style.setProperty('background', 'rgba(0, 0, 0, 0.9)', 'important');
                    this.style.setProperty('border-color', '#667eea', 'important');
                    console.log('Select focused:', this.id);
                });
                
                select.addEventListener('change', function() {
                    console.log('Select changed to:', this.value, this.options[this.selectedIndex].text);
                    // Flash effect to confirm selection
                    this.style.setProperty('border-color', '#00ff88', 'important');
                    setTimeout(() => {
                        this.style.setProperty('border-color', '#667eea', 'important');
                    }, 300);
                });
            });
        }

        // Observer to catch any dynamically added selects
        const dropdownObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    const addedSelects = [];
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            if (node.tagName === 'SELECT') {
                                addedSelects.push(node);
                            }
                            const childSelects = node.querySelectorAll ? node.querySelectorAll('select') : [];
                            addedSelects.push(...childSelects);
                        }
                    });
                    
                    if (addedSelects.length > 0) {
                        console.log('ðŸ” Detected new select elements, fixing...');
                        setTimeout(fixDropdownVisibility, 50);
                    }
                }
            });
        });

        // Manual trigger function for testing
        window.debugFixDropdowns = function() {
            console.log('ðŸ› Manual dropdown fix triggered');
            fixDropdownVisibility();
        };

        // Initialize App
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ðŸš€ MindOS AI-Powered Never-Ending Feed Starting...');
            
            // Start observing the edit overlay for dropdown fixes
            const editOverlay = document.getElementById('editOverlay');
            if (editOverlay) {
                dropdownObserver.observe(editOverlay, {
                    childList: true,
                    subtree: true
                });
            }
            
            if (authToken) {
                const isValid = await validateToken();
                if (isValid) {
                    await loadDatabaseSchema();
                    showFeed();
                    return;
                }
            }
            
            showLogin();
        });

        // Authentication Functions
        function showLogin() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
        }

        function showRegister() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
        }

        async function validateToken() {
            try {
                const response = await fetch('/api/user-status', {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentUser = data.user;
                    return true;
                }
            } catch (error) {
                console.error('Token validation failed:', error);
            }
            
            localStorage.removeItem('mindos_token');
            authToken = null;
            return false;
        }

        // Login Form Handler
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const btn = document.getElementById('loginBtn');
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('mindos_token', authToken);
                    
                    showToast('Welcome back!', 'success');
                    await loadDatabaseSchema();
                    showFeed();
                } else {
                    showToast(data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showToast('Network error. Please try again.', 'error');
                console.error('Login error:', error);
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });

        // Register Form Handler
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const btn = document.getElementById('registerBtn');
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;
            
            if (!username || !email || !password) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            if (password.length < 6) {
                showToast('Password must be at least 6 characters', 'error');
                return;
            }
            
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('mindos_token', authToken);
                    
                    showToast('Account created successfully!', 'success');
                    await loadDatabaseSchema();
                    showFeed();
                } else {
                    showToast(data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showToast('Network error. Please try again.', 'error');
                console.error('Register error:', error);
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });

        // ENHANCED: Load Database Schema with detailed analysis
        async function loadDatabaseSchema() {
            try {
                const response = await fetch('/api/debug/schema', {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    databaseSchema = await response.json();
                    console.log('ðŸ“Š Database schema loaded:', databaseSchema);
                    console.log('ðŸ“‹ Available columns:', databaseSchema.memoriesTableColumns);
                    
                    // Log column analysis for debugging
                    if (databaseSchema.memoriesTableColumns) {
                        console.log('ðŸ” Column analysis:');
                        console.log('  - Total columns:', databaseSchema.memoriesTableColumns.length);
                        console.log('  - Has type:', databaseSchema.hasTypeColumn);
                        console.log('  - Has content:', databaseSchema.hasContentColumn);
                        console.log('  - Has priority:', databaseSchema.hasPriorityColumn);
                    }
                } else {
                    console.error('Failed to load database schema');
                    showToast('Warning: Could not load database schema', 'warning');
                }
            } catch (error) {
                console.error('Error loading database schema:', error);
                showToast('Warning: Database schema unavailable', 'warning');
            }
        }

        // NEW: Never-Ending Feed Functions
        async function showFeed() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('feedContainer').style.display = 'block';
            
            if (currentUser) {
                document.getElementById('feedUserName').textContent = currentUser.username;
            }
            
            if (!databaseSchema) {
                await loadDatabaseSchema();
            }
            
            await loadInitialFeed();
            setupContinuousScrollListener();
        }

        async function loadInitialFeed() {
            feedItems = [];
            currentPage = 0;
            hasMoreItems = true;
            
            // Clear existing content
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.innerHTML = '';
            
            await loadMoreItems();
        }

        async function loadMoreItems() {
            if (isLoadingMore || !hasMoreItems) return;
            
            isLoadingMore = true;
            showLoadingIndicator();
            
            try {
                // Try enhanced endpoint first, fallback to basic
                // IMPORTANT: Exclude completed items from the feed
                const offset = currentPage * ITEMS_PER_PAGE;
                let response = await fetch(`/api/memories/enhanced?limit=${ITEMS_PER_PAGE}&offset=${offset}&sort_by=priority&sort_order=desc&exclude_completed=true`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                let data;
                if (response.ok) {
                    data = await response.json();
                } else {
                    // Fallback to basic endpoint
                    response = await fetch(`/api/memories?limit=${ITEMS_PER_PAGE}`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const memories = await response.json();
                        data = { memories: memories.slice(offset, offset + ITEMS_PER_PAGE) };
                    }
                }
                
                if (response.ok && data) {
                    const newItems = data.memories || [];
                    
                    if (newItems.length === 0) {
                        hasMoreItems = false;
                        showEndOfFeed();
                    } else {
                        feedItems = [...feedItems, ...newItems];
                        appendFeedCards(newItems);
                        currentPage++;
                        
                        // Check if we have more items
                        if (newItems.length < ITEMS_PER_PAGE) {
                            hasMoreItems = false;
                            showEndOfFeed();
                        }
                    }
                } else {
                    showToast('Error loading items', 'error');
                }
            } catch (error) {
                console.error('Error loading more items:', error);
                showToast('Network error loading items', 'error');
            } finally {
                isLoadingMore = false;
                hideLoadingIndicator();
                updateScrollIndicator();
            }
        }

        function appendFeedCards(items) {
            const feedScroll = document.getElementById('feedScroll');
            
            items.forEach((item, index) => {
                const card = createFeedCard(item, feedItems.indexOf(item));
                feedScroll.appendChild(card);
            });
            
            document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
            document.getElementById('totalItemsCount').textContent = feedItems.length;
        }

        function createFeedCard(item, index) {
            const card = document.createElement('div');
            card.className = 'feed-card';
            card.dataset.index = index;
            card.dataset.itemId = item.id;
            
            // Vary card heights for visual interest
            if (item.type === 'routine' || (item.content && item.content.length > 100)) {
                card.classList.add('expanded');
            } else {
                card.classList.add('compact');
            }
            
            const priority = parseInt(item.priority) || 1;
            const priorityStars = 'â˜…'.repeat(priority);
            
            const typeColors = {
                routine: '#667eea',
                goal: '#764ba2',
                task: '#f093fb',
                note: '#4facfe',
                preference: '#43e97b',
                insight: '#fa709a'
            };
            
            card.innerHTML = `
                <div class="card-content-area">
                    <div class="card-type-badge" style="background: ${typeColors[item.type] || '#667eea'};">
                        ${item.type || 'item'}
                    </div>
                    <div class="card-priority">${priorityStars}</div>
                    
                    <div class="card-main-content">
                        <h2 class="card-title">${item.content_short || (item.content ? item.content.substring(0, 100) : 'Untitled')}</h2>
                        <p class="card-description">${item.notes || (item.content ? item.content.substring(100, 300) : 'No additional details')}</p>
                        
                        <div class="card-meta">
                            <span>Status: ${item.status || 'active'}</span>
                            <span>${item.routine_type || ''}</span>
                        </div>
                    </div>
                </div>
                
                <div class="card-actions">
                    <button class="action-btn ai-chat" onclick="openAIChat(${item.id})" title="AI Chat">
                        <i class="fas fa-brain"></i>
                    </button>
                    
                    <button class="action-btn ${item.status === 'completed' ? 'completed' : ''}" onclick="toggleComplete(${item.id})" title="Mark Complete">
                        <i class="fas fa-check"></i>
                    </button>
                    
                    <button class="action-btn" onclick="editItem(${item.id})" title="Edit Item">
                        <i class="fas fa-edit"></i>
                    </button>
                    
                    <button class="action-btn" onclick="shareItem(${item.id})" title="Share Item">
                        <i class="fas fa-share"></i>
                    </button>
                    
                    <button class="action-btn" onclick="deleteItem(${item.id})" title="Delete Item">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            return card;
        }

        function showLoadingIndicator() {
            const feedScroll = document.getElementById('feedScroll');
            const existingLoader = document.getElementById('loadingMore');
            
            if (!existingLoader) {
                const loader = document.createElement('div');
                loader.id = 'loadingMore';
                loader.className = 'loading-more';
                loader.innerHTML = `
                    <div class="loading-spinner"></div>
                    <p>Loading more items...</p>
                `;
                feedScroll.appendChild(loader);
            }
        }

        function hideLoadingIndicator() {
            const loader = document.getElementById('loadingMore');
            if (loader) {
                loader.remove();
            }
        }

        function showEndOfFeed() {
            const feedScroll = document.getElementById('feedScroll');
            const existingEnd = document.getElementById('endOfFeed');
            
            if (!existingEnd && feedItems.length > 0) {
                const endCard = document.createElement('div');
                endCard.id = 'endOfFeed';
                endCard.className = 'end-of-feed';
                endCard.innerHTML = `
                    <div class="brain-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <h2>You've reached the end!</h2>
                    <p>Great job staying on top of your tasks and goals. You've reviewed all ${feedItems.length} items in your MindOS feed.</p>
                    
                    <div class="end-actions">
                        <button class="end-btn" onclick="scrollToTop()">
                            <i class="fas fa-arrow-up"></i> Back to Top
                        </button>
                        <button class="end-btn" onclick="showAddItem()">
                            <i class="fas fa-plus"></i> Add New Item
                        </button>
                        <button class="end-btn" onclick="refreshFeed()">
                            <i class="fas fa-refresh"></i> Refresh Feed
                        </button>
                    </div>
                `;
                feedScroll.appendChild(endCard);
            }
        }

        // NEW: Continuous Scroll Management
        function setupContinuousScrollListener() {
            const feedScroll = document.getElementById('feedScroll');
            
            feedScroll.addEventListener('scroll', () => {
                updateScrollIndicator();
                
                // Load more items when near bottom
                const scrollHeight = feedScroll.scrollHeight;
                const scrollTop = feedScroll.scrollTop;
                const clientHeight = feedScroll.clientHeight;
                
                if (scrollHeight - scrollTop - clientHeight < 1000) {
                    loadMoreItems();
                }
            });
        }

        function updateScrollIndicator() {
            const feedScroll = document.getElementById('feedScroll');
            const scrollPercentage = (feedScroll.scrollTop / (feedScroll.scrollHeight - feedScroll.clientHeight)) * 100;
            
            document.getElementById('scrollProgressFill').style.height = `${Math.max(0, Math.min(100, scrollPercentage))}%`;
            
            // Calculate current item based on scroll position
            const cards = document.querySelectorAll('.feed-card');
            let currentItem = 1;
            
            cards.forEach((card, index) => {
                const rect = card.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    currentItem = index + 1;
                }
            });
            
            document.getElementById('currentItemNumber').textContent = currentItem;
        }

        function scrollToTop() {
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // ===== ENHANCED DATA FORMATTING FUNCTIONS =====

        // NEW: Get database column types and constraints
        async function getTableStructure() {
            try {
                // If we have schema info, use it
                if (databaseSchema && databaseSchema.memoriesTableColumns) {
                    return {
                        columns: databaseSchema.memoriesTableColumns,
                        types: await getColumnTypes()
                    };
                }
                
                // Fallback to a basic set of known columns
                return {
                    columns: ['id', 'user_id', 'type', 'content', 'content_short', 'priority', 'status', 'created_at'],
                    types: {}
                };
            } catch (error) {
                console.error('Error getting table structure:', error);
                return { columns: [], types: {} };
            }
        }

        // NEW: Get column data types from server
        async function getColumnTypes() {
            try {
                // This would ideally come from a dedicated endpoint, 
                // but we'll infer from common patterns
                return {
                    'id': 'integer',
                    'user_id': 'string',
                    'type': 'string',
                    'content': 'text',
                    'content_short': 'string',
                    'priority': 'integer',
                    'status': 'string',
                    'due': 'date',
                    'created_at': 'timestamp',
                    'modified': 'date',
                    'completed_date': 'date',
                    'performance_streak': 'integer',
                    'required_time': 'string'
                };
            } catch (error) {
                console.error('Error getting column types:', error);
                return {};
            }
        }

        // ===== UNIFIED EDIT/ADD FUNCTIONS =====
        
        function getAvailableFields() {
            if (!databaseSchema || !databaseSchema.memoriesTableColumns) {
                return ['content', 'notes', 'type', 'status', 'priority', 'due', 'routine_type', 'goal_type'];
            }
            
            const excludeFields = ['id', 'user_id', 'created_at'];
            return databaseSchema.memoriesTableColumns.filter(col => !excludeFields.includes(col));
        }

        function createFieldElement(fieldName, value = '', isCore = false) {
            const fieldId = `edit_${fieldName}`;
            const label = fieldName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            const selectFields = {
                'type': ['routine', 'goal', 'task', 'note', 'preference', 'insight', 'event'],
                'status': ['active', 'completed', 'paused', 'archived'],
                'priority': [
                    { value: 1, label: 'Low Priority' },
                    { value: 2, label: 'Medium Priority' },
                    { value: 3, label: 'Normal Priority' },
                    { value: 4, label: 'High Priority' },
                    { value: 5, label: 'Critical Priority' }
                ],
                'stage': ['planning', 'in_progress', 'review', 'completed', 'on_hold'],
                'routine_type': ['morning', 'evening', 'daily', 'weekly', 'workout', 'health'],
                'goal_type': ['personal', 'professional', 'health', 'financial', 'learning']
            };
            
            const textAreaFields = ['content', 'notes', 'success_criteria', 'description'];
            const numberFields = ['performance_streak', 'required_time_minutes', 'priority'];
            const dateFields = ['due', 'modified', 'completed_date', 'target_date'];
            
            let inputHTML = '';
            
            if (selectFields[fieldName]) {
                const options = selectFields[fieldName];
                let optionsHTML = `<option value="">Select ${label}</option>`;
                
                if (Array.isArray(options) && typeof options[0] === 'object') {
                    optionsHTML += options.map(opt => 
                        `<option value="${opt.value}" ${value == opt.value ? 'selected' : ''}>${opt.label}</option>`
                    ).join('');
                } else {
                    optionsHTML += options.map(opt => 
                        `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt.charAt(0).toUpperCase() + opt.slice(1)}</option>`
                    ).join('');
                }
                
                inputHTML = `<select id="${fieldId}" class="edit-input">${optionsHTML}</select>`;
            } else if (textAreaFields.includes(fieldName)) {
                inputHTML = `<textarea id="${fieldId}" class="edit-input" rows="4" placeholder="${label}">${value || ''}</textarea>`;
            } else if (numberFields.includes(fieldName)) {
                inputHTML = `<input type="number" id="${fieldId}" class="edit-input" placeholder="${label}" value="${value || ''}">`;
            } else if (dateFields.includes(fieldName)) {
                const dateValue = value ? value.split('T')[0] : '';
                inputHTML = `<input type="date" id="${fieldId}" class="edit-input" value="${dateValue}">`;
            } else {
                inputHTML = `<input type="text" id="${fieldId}" class="edit-input" placeholder="${label}" value="${value || ''}">`;
            }
            
            const removeBtn = isCore ? '' : `<button type="button" class="field-remove-btn" onclick="removeField('${fieldName}')" title="Remove field">Ã—</button>`;
            
            return `
                <div class="form-group" data-field="${fieldName}">
                    <label for="${fieldId}">${label} ${removeBtn}</label>
                    ${inputHTML}
                </div>
            `;
        }

        // ENHANCED: Field value formatting function
        function formatFieldValue(fieldName, value) {
            if (value === null || value === undefined || value === '') {
                return null;
            }
            
            // Field-specific formatting
            switch (fieldName) {
                case 'priority':
                case 'performance_streak':
                case 'required_time_minutes':
                    const numVal = parseInt(value);
                    return isNaN(numVal) ? null : numVal;
                    
                case 'due':
                case 'completed_date':
                case 'target_date':
                    if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) {
                        return value.split('T')[0]; // Ensure date format
                    }
                    return value;
                    
                case 'content':
                case 'notes':
                    // Ensure content_short is generated if not provided
                    const trimmed = String(value).trim();
                    if (fieldName === 'content' && trimmed.length > 100) {
                        // Auto-generate content_short if not already provided
                        const shortContent = trimmed.substring(0, 97) + '...';
                        // This will be handled separately, just return the full content
                    }
                    return trimmed;
                    
                case 'type':
                case 'status':
                case 'routine_type':
                case 'goal_type':
                case 'stage':
                    return String(value).trim().toLowerCase();
                    
                default:
                    return typeof value === 'string' ? value.trim() : value;
            }
        }

        // ENHANCED: Debug function for troubleshooting edits
        async function debugEditItem(itemId) {
            if (!debugMode) {
                console.log('Enable debug mode first: debugMode = true');
                return;
            }
            
            try {
                console.log('ðŸ› Debug analysis for item:', itemId);
                
                const response = await fetch(`/api/debug/memory/${itemId}`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    const debug = await response.json();
                    console.log('ðŸ› Debug results:', debug);
                    
                    console.table({
                        'Memory ID': debug.memory.id,
                        'Content': debug.memory.content?.substring(0, 50) + '...',
                        'Type': debug.memory.type,
                        'Status': debug.memory.status,
                        'Priority': debug.memory.priority,
                        'User ID': debug.memory.user_id
                    });
                    
                    console.log('ðŸ“‹ Available columns:', debug.schema.availableColumns);
                    console.log('ðŸ” Analysis:', debug.analysis);
                    
                    return debug;
                } else {
                    console.error('Debug request failed:', response.status);
                }
            } catch (error) {
                console.error('Debug error:', error);
            }
        }

        // ENHANCED: Build form for both add and edit modes - WITH DROPDOWN FIX INTEGRATION
        function buildEditForm(item, isAdd = false) {
            console.log('ðŸ—ï¸ Building edit form, isAdd:', isAdd);
            console.log('ðŸ“‹ Item data:', item);
            
            const coreContainer = document.getElementById('coreFields');
            const optionalContainer = document.getElementById('optionalFields');
            const availableContainer = document.getElementById('fieldTags');
            const fieldControls = document.getElementById('fieldControls');
            const editTitle = document.getElementById('editTitle');
            const saveBtn = document.getElementById('saveEditBtn');
            
            // Set mode
            isAddMode = isAdd;
            activeOptionalFields.clear();
            
            console.log(`ðŸ”§ Building form - Add mode: ${isAddMode}`);
            
            // Update UI for mode
            if (isAddMode) {
                editTitle.textContent = 'Add New Item';
                saveBtn.textContent = 'Create Item';
                fieldControls.style.display = 'block';
            } else {
                editTitle.textContent = `Edit Item #${item.id}`;
                saveBtn.textContent = 'Save Changes';
                fieldControls.style.display = 'block';
            }
            
            // Get available fields from schema
            const availableFields = getAvailableFields();
            console.log('ðŸ“‹ Available fields from schema:', availableFields);
            
            // Build core fields
            let coreHTML = '';
            const fieldsToShow = isAddMode ? BASIC_ADD_FIELDS : CORE_FIELDS;
            
            fieldsToShow.forEach(fieldName => {
                if (availableFields.includes(fieldName)) {
                    const value = item[fieldName] || '';
                    console.log(`ðŸ”§ Building core field ${fieldName} with value:`, value);
                    coreHTML += createFieldElement(fieldName, value, true);
                }
            });
            coreContainer.innerHTML = coreHTML;
            
            // Clear optional fields
            optionalContainer.innerHTML = '';
            optionalContainer.classList.add('collapsed');
            
            // Build available fields tags
            let tagsHTML = '';
            availableFields.forEach(fieldName => {
                if (!fieldsToShow.includes(fieldName)) {
                    const hasValue = item[fieldName] !== null && item[fieldName] !== undefined && item[fieldName] !== '';
                    const tagClass = hasValue ? 'field-tag added' : 'field-tag';
                    const label = fieldName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    tagsHTML += `<span class="${tagClass}" data-field="${fieldName}" onclick="addField('${fieldName}')">${label}</span>`;
                    
                    if (hasValue) {
                        activeOptionalFields.add(fieldName);
                    }
                }
            });
            availableContainer.innerHTML = tagsHTML;
            
            // Auto-show optional fields if any have values (for edit mode)
            if (!isAddMode && activeOptionalFields.size > 0) {
                showOptionalFieldsWithValues(item);
            }
            
            // Apply dropdown fix after form is built
            setTimeout(fixDropdownVisibility, 150);
            
            console.log('âœ… Form built successfully');
        }

        function showOptionalFieldsWithValues(item) {
            const optionalContainer = document.getElementById('optionalFields');
            let optionalHTML = '';
            
            activeOptionalFields.forEach(fieldName => {
                optionalHTML += createFieldElement(fieldName, item[fieldName], false);
            });
            
            optionalContainer.innerHTML = optionalHTML;
            optionalContainer.classList.remove('collapsed');
            
            // Fix dropdowns in optional fields too
            setTimeout(fixDropdownVisibility, 100);
        }

        function toggleOptionalFields() {
            const optionalContainer = document.getElementById('optionalFields');
            optionalContainer.classList.toggle('collapsed');
        }

        function toggleAvailableFields() {
            const availableContainer = document.getElementById('availableFields');
            availableContainer.classList.toggle('show');
        }

        function addField(fieldName) {
            if (activeOptionalFields.has(fieldName)) {
                const fieldElement = document.querySelector(`[data-field="${fieldName}"]`);
                if (fieldElement) {
                    fieldElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return;
            }
            
            activeOptionalFields.add(fieldName);
            
            const tag = document.querySelector(`[data-field="${fieldName}"]`);
            if (tag) {
                tag.classList.add('added');
            }
            
            const optionalContainer = document.getElementById('optionalFields');
            const fieldHTML = createFieldElement(fieldName, currentEditItem[fieldName], false);
            optionalContainer.insertAdjacentHTML('beforeend', fieldHTML);
            
            optionalContainer.classList.remove('collapsed');
            
            // Fix any new dropdowns that were added
            setTimeout(fixDropdownVisibility, 50);
            
            showToast(`Added ${fieldName.replace(/_/g, ' ')} field`, 'success');
        }

        function removeField(fieldName) {
            const fieldsToShow = isAddMode ? BASIC_ADD_FIELDS : CORE_FIELDS;
            if (fieldsToShow.includes(fieldName)) {
                showToast('Cannot remove essential field', 'error');
                return;
            }
            
            activeOptionalFields.delete(fieldName);
            
            const fieldElement = document.querySelector(`[data-field="${fieldName}"]`);
            if (fieldElement) {
                fieldElement.remove();
            }
            
            const tag = document.querySelector(`span[data-field="${fieldName}"]`);
            if (tag) {
                tag.classList.remove('added');
            }
            
            showToast(`Removed ${fieldName.replace(/_/g, ' ')} field`, 'success');
        }

        // UNIFIED: Show Add Item (replaces showQuickAdd) - WITH DROPDOWN FIX INTEGRATION
        function showAddItem() {
            console.log('âž• Showing add item form');
            
            const emptyItem = {
                type: 'task',
                content: '',
                priority: 3,
                due: '',
                status: 'active'
            };
            
            currentEditItem = emptyItem;
            buildEditForm(emptyItem, true); // true = add mode
            document.getElementById('editOverlay').classList.add('show');
            
            // Apply dropdown fix after overlay is shown
            setTimeout(fixDropdownVisibility, 150);
        }

        // ENHANCED: Edit function with better error handling
        function editItem(itemId) {
            console.log('ðŸ“ Editing item:', itemId);
            
            // ENSURE ID IS PROPERLY CONVERTED
            const numericId = parseInt(itemId);
            if (isNaN(numericId)) {
                showToast('Invalid item ID', 'error');
                return;
            }
            
            const item = feedItems.find(i => i.id == numericId); // Use == for type coercion
            if (!item) {
                console.error('âŒ Item not found in feedItems:', numericId);
                console.log('ðŸ“‹ Available items:', feedItems.map(i => ({ id: i.id, type: typeof i.id })));
                showToast('Item not found', 'error');
                return;
            }
            
            console.log('ðŸ“ Found item for editing:', item);
            currentEditItem = item;
            buildEditForm(item, false); // false = edit mode
            document.getElementById('editOverlay').classList.add('show');
            
            // Apply dropdown fix after overlay is shown
            setTimeout(fixDropdownVisibility, 150);
        }

        function closeEdit() {
            document.getElementById('editOverlay').classList.remove('show');
            document.getElementById('availableFields').classList.remove('show');
            currentEditItem = null;
            activeOptionalFields.clear();
            isAddMode = false;
        }

        // ENHANCED SAVE FUNCTION WITH BETTER ERROR HANDLING AND DEBUGGING
        async function saveEdit() {
            if (!currentEditItem) {
                showToast('No item to save', 'error');
                return;
            }
            
            console.log('ðŸ’¾ Starting enhanced save process');
            console.log('ðŸ“‹ Current edit item:', currentEditItem);
            console.log('ðŸ”§ Add mode:', isAddMode);
            
            // Get button reference and original text BEFORE try block
            const saveBtn = document.getElementById('saveEditBtn');
            const originalText = saveBtn ? saveBtn.textContent : 'Save Changes';
            
            try {
                // Collect form data with better validation
                const rawData = {};
                const allInputs = document.querySelectorAll('#coreFields input, #coreFields textarea, #coreFields select, #optionalFields input, #optionalFields textarea, #optionalFields select');
                
                console.log(`ðŸ“Š Found ${allInputs.length} form inputs`);
                
                allInputs.forEach(input => {
                    const fieldName = input.id.replace('edit_', '');
                    let value = input.value;
                    
                    // Handle different input types
                    if (input.type === 'number') {
                        value = value === '' ? null : Number(value);
                    } else if (input.type === 'date') {
                        value = value === '' ? null : value;
                    } else if (input.tagName === 'SELECT') {
                        value = value === '' ? null : value;
                    } else {
                        value = value.trim();
                        if (value === '') value = null;
                    }
                    
                    rawData[fieldName] = value;
                    console.log(`ðŸ“ Raw field ${fieldName}:`, value, `(type: ${typeof value})`);
                });
                
                // ENHANCED: Validate essential fields
                const validationErrors = [];
                
                if (!rawData.content || (typeof rawData.content === 'string' && rawData.content.trim() === '')) {
                    validationErrors.push('Content is required');
                }
                
                if (isAddMode && (!rawData.type || rawData.type.trim() === '')) {
                    validationErrors.push('Type is required for new items');
                }
                
                if (validationErrors.length > 0) {
                    showToast(`Validation errors: ${validationErrors.join(', ')}`, 'error');
                    return;
                }
                
                // ENHANCED: Data formatting specific to database expectations
                const formattedData = {};
                
                Object.entries(rawData).forEach(([key, value]) => {
                    // Skip system fields
                    if (['id', 'user_id', 'created_at'].includes(key)) {
                        return;
                    }
                    
                    // Format based on field type
                    formattedData[key] = formatFieldValue(key, value);
                });
                
                console.log('ðŸŽ¯ Formatted data for submission:', formattedData);
                
                // Show loading state
                if (saveBtn) {
                    saveBtn.textContent = 'Saving...';
                    saveBtn.disabled = true;
                    saveBtn.classList.add('loading');
                }
                
                let response;
                let url;
                let method;
                
                if (isAddMode) {
                    // Create new item
                    console.log('ðŸ†• Creating new item with data:', formattedData);
                    url = '/api/memories';
                    method = 'POST';
                } else {
                    // Update existing item - ENSURE ID IS PROPERLY PASSED
                    const itemId = currentEditItem.id;
                    console.log(`ðŸ”„ Updating item ${itemId} with data:`, formattedData);
                    
                    if (!itemId) {
                        throw new Error('No item ID found for update');
                    }
                    
                    url = `/api/memories/${itemId}`;
                    method = 'PUT';
                }
                
                console.log(`ðŸ“¡ Making ${method} request to ${url}`);
                
                response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(formattedData)
                });
                
                console.log('ðŸ“¡ Response status:', response.status);
                console.log('ðŸ“¡ Response headers:', Object.fromEntries(response.headers.entries()));
                
                // ENHANCED: Better error handling
                if (response.ok) {
                    const result = await response.json();
                    console.log('âœ… Save successful:', result);
                    
                    if (isAddMode) {
                        showToast('âœ… Item created successfully!', 'success');
                        // Add to feedItems array for immediate UI update
                        feedItems.unshift(result);
                    } else {
                        // Update the item in feedItems array
                        const itemIndex = feedItems.findIndex(item => item.id === currentEditItem.id);
                        if (itemIndex !== -1) {
                            feedItems[itemIndex] = { ...feedItems[itemIndex], ...result };
                        }
                        showToast('âœ… Changes saved successfully!', 'success');
                    }
                    
                    closeEdit();
                    await refreshFeed(); // Refresh to show changes
                } else {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: `HTTP ${response.status} ${response.statusText}` };
                    }
                    
                    console.error('âŒ Save failed:', errorData);
                    console.error('âŒ Response status:', response.status);
                    
                    // Show specific error information
                    if (response.status === 404) {
                        showToast('âŒ Item not found - it may have been deleted', 'error');
                    } else if (response.status === 400) {
                        showToast(`âŒ ${errorData.error || 'Invalid data provided'}`, 'error');
                    } else if (response.status === 403) {
                        showToast('âŒ Access denied - please log in again', 'error');
                    } else {
                        showToast(`âŒ ${errorData.error || 'Failed to save changes'}`, 'error');
                    }
                    
                    // Log debug information
                    if (debugMode || process.env.NODE_ENV === 'development') {
                        console.log('ðŸ› Debug information:');
                        console.log('  - Item ID:', currentEditItem?.id);
                        console.log('  - Formatted data:', formattedData);
                        console.log('  - Response:', errorData);
                    }
                }
                
            } catch (error) {
                console.error('âŒ Network/JS error during save:', error);
                showToast('âŒ Network error - please check your connection and try again', 'error');
                
                // Additional debugging for network errors
                console.error('ðŸ› Error details:', {
                    message: error.message,
                    stack: error.stack,
                    currentEditItem: currentEditItem?.id,
                    isAddMode: isAddMode
                });
            } finally {
                // Always restore button state
                if (saveBtn) {
                    saveBtn.textContent = originalText || 'Save Changes';
                    saveBtn.disabled = false;
                    saveBtn.classList.remove('loading');
                }
            }
        }

        // ===== AI CHAT FUNCTIONS =====
        
        // Build comprehensive context for AI to understand the item
        function buildItemContext(item) {
            const context = {
                itemId: item.id,
                type: item.type || 'general',
                currentStatus: item.status || 'active',
                priority: item.priority || 3,
                content: item.content || '',
                contentShort: item.content_short || '',
                
                // Time-related fields
                created: item.created_at ? new Date(item.created_at).toLocaleDateString() : 'Unknown',
                due: item.due ? new Date(item.due).toLocaleDateString() : 'Not set',
                completedDate: item.completed_date ? new Date(item.completed_date).toLocaleDateString() : null,
                modified: item.modified ? new Date(item.modified).toLocaleDateString() : null,
                
                // Additional metadata
                stage: item.stage || null,
                routineType: item.routine_type || null,
                goalType: item.goal_type || null,
                frequency: item.frequency || null,
                location: item.location || null,
                mood: item.mood || null,
                trigger: item.trigger || null,
                performanceStreak: item.performance_streak || 0,
                requiredTime: item.required_time_minutes || null,
                notes: item.notes || '',
                successCriteria: item.success_criteria || ''
            };
            
            // Build contextual prompt
            let contextPrompt = `You are MindOS AI assistant, helping with a specific ${context.type} item.

ITEM CONTEXT:
- ID: ${context.itemId}
- Type: ${context.type}
- Status: ${context.currentStatus}
- Priority: ${context.priority} (1=Low, 5=Critical)
- Content: "${context.content}"
- Created: ${context.created}
`;

            // Add relevant fields based on type
            if (context.due !== 'Not set') contextPrompt += `- Due: ${context.due}\n`;
            if (context.completedDate) contextPrompt += `- Completed: ${context.completedDate}\n`;
            if (context.stage) contextPrompt += `- Stage: ${context.stage}\n`;
            if (context.frequency) contextPrompt += `- Frequency: ${context.frequency}\n`;
            if (context.location) contextPrompt += `- Location: ${context.location}\n`;
            if (context.performanceStreak > 0) contextPrompt += `- Performance Streak: ${context.performanceStreak} days\n`;
            if (context.requiredTime) contextPrompt += `- Required Time: ${context.requiredTime} minutes\n`;
            if (context.notes) contextPrompt += `- Notes: ${context.notes}\n`;
            if (context.successCriteria) contextPrompt += `- Success Criteria: ${context.successCriteria}\n`;
            
            // Type-specific context
            if (context.type === 'routine' && context.routineType) {
                contextPrompt += `- Routine Type: ${context.routineType}\n`;
            }
            if (context.type === 'goal' && context.goalType) {
                contextPrompt += `- Goal Type: ${context.goalType}\n`;
            }
            
            contextPrompt += `
CAPABILITIES:
You can help the user by:
1. Updating any field of this item (content, status, priority, due date, etc.)
2. Marking as complete or changing status
3. Adding or modifying notes
4. Setting or changing due dates
5. Adjusting priority
6. Providing advice specific to this ${context.type}
7. Breaking down complex items into subtasks
8. Suggesting improvements based on the item's context

IMPORTANT CONSTRAINTS:
- You can ONLY discuss and modify THIS specific item (ID: ${context.itemId})
- You cannot access or modify other items in the user's list
- All suggestions should be relevant to this specific ${context.type}
- When the user asks to update something, provide clear confirmation of what will be changed
- If the user asks about unrelated topics, politely redirect to this specific item

AVAILABLE FIELDS YOU CAN MODIFY:
- content, type, status (active/completed/paused/archived)
- priority (1-5), due date, notes, stage
- location, frequency, required_time_minutes
- success_criteria, mood, trigger
${context.type === 'routine' ? '- routine_type (morning/evening/daily/weekly/workout/health)' : ''}
${context.type === 'goal' ? '- goal_type (personal/professional/health/financial/learning)' : ''}

Please be helpful, contextual, and focused on this specific item.`;
            
            return contextPrompt;
        }

        function openAIChat(itemId) {
            const item = feedItems.find(i => i.id === itemId);
            if (!item) {
                showToast('Item not found', 'error');
                return;
            }
            
            currentAIItem = item;
            aiChatHistory = item.ai_chat_history ? JSON.parse(item.ai_chat_history) : [];
            
            // Update chat header with more context
            const priorityLabels = {1: 'Low', 2: 'Medium', 3: 'Normal', 4: 'High', 5: 'Critical'};
            document.getElementById('aiChatItemTitle').textContent = item.content_short || (item.content ? item.content.substring(0, 50) : 'Untitled');
            document.getElementById('aiChatItemType').textContent = `${item.type || 'item'} â€¢ ${priorityLabels[item.priority] || 'Normal'} Priority â€¢ ${item.status || 'active'}`;
            
            // Render chat history
            renderAIChatHistory();
            
            // Show overlay
            document.getElementById('aiChatOverlay').classList.add('show');
            
            // Focus input
            setTimeout(() => {
                document.getElementById('aiChatInput').focus();
            }, 300);
            
            // Add context-aware welcome message if no history
            if (aiChatHistory.length === 0) {
                const welcomeMessage = generateWelcomeMessage(item);
                addAIMessage('assistant', welcomeMessage);
            }
        }
        
        // Generate a context-aware welcome message
        function generateWelcomeMessage(item) {
            let message = `Hi! I'm here to help you with this ${item.type || 'item'}: "${item.content_short || item.content}"\n\n`;
            
            // Add status-specific suggestions
            if (item.status === 'active') {
                message += `I can help you:\nâ€¢ Mark it as complete\nâ€¢ Set or update the due date\nâ€¢ Break it into smaller tasks\nâ€¢ Add notes or details\n`;
            } else if (item.status === 'completed') {
                message += `This item is completed! I can help you:\nâ€¢ Reactivate it\nâ€¢ Create a similar item\nâ€¢ Add completion notes\n`;
            }
            
            // Add type-specific suggestions
            if (item.type === 'routine') {
                message += `â€¢ Adjust the frequency (currently: ${item.frequency || 'not set'})\nâ€¢ Track your streak (currently: ${item.performance_streak || 0} days)\n`;
            } else if (item.type === 'goal') {
                message += `â€¢ Update progress towards the goal\nâ€¢ Set milestones\nâ€¢ Adjust the target date\n`;
            }
            
            // Add priority-specific note
            if (item.priority >= 4) {
                message += `\nâš¡ This is a high priority item. Would you like help planning immediate next steps?`;
            }
            
            message += `\nWhat would you like to do?`;
            return message;
        }

        function closeAIChat() {
            document.getElementById('aiChatOverlay').classList.remove('show');
            currentAIItem = null;
        }

        function renderAIChatHistory() {
            const container = document.getElementById('aiChatMessages');
            container.innerHTML = '';
            
            aiChatHistory.forEach(message => {
                addAIMessageToDOM(message.role, message.content);
            });
            
            scrollChatToBottom();
        }

        function addAIMessage(role, content) {
            const message = { role, content, timestamp: new Date().toISOString() };
            aiChatHistory.push(message);
            addAIMessageToDOM(role, content);
            scrollChatToBottom();
        }

        function addAIMessageToDOM(role, content) {
            const container = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${role}`;
            
            const avatarIcon = role === 'user' ? 'fas fa-user' : 'fas fa-brain';
            
            messageDiv.innerHTML = `
                <div class="ai-message-avatar">
                    <i class="${avatarIcon}"></i>
                </div>
                <div class="ai-message-content">${content}</div>
            `;
            
            container.appendChild(messageDiv);
        }

        function scrollChatToBottom() {
            const container = document.getElementById('aiChatMessages');
            container.scrollTop = container.scrollHeight;
        }

        async function sendAIMessage() {
            const input = document.getElementById('aiChatInput');
            const sendBtn = document.getElementById('aiChatSend');
            const message = input.value.trim();
            
            if (!message || !currentAIItem) return;
            
            // Add user message
            addAIMessage('user', message);
            input.value = '';
            
            // Show loading
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            
            try {
                // Build comprehensive context for the AI
                const itemContext = buildItemContext(currentAIItem);
                
                // Send to Claude API for processing
                const response = await fetch('/api/claude', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        messages: [
                            { role: 'system', content: itemContext },
                            ...aiChatHistory,
                            { role: 'user', content: message }
                        ]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add AI response
                    const aiResponse = data.content[0].text;
                    addAIMessage('assistant', aiResponse);
                    
                    // Save chat history to item
                    await saveChatHistory();
                    
                } else {
                    addAIMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                }
                
            } catch (error) {
                console.error('AI Chat error:', error);
                addAIMessage('assistant', 'Sorry, I encountered an error. Please try again.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
            }
        }

        async function saveChatHistory() {
            try {
                await fetch(`/api/memories/${currentAIItem.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        ai_chat_history: JSON.stringify(aiChatHistory)
                    })
                });
            } catch (error) {
                console.error('Error saving chat history:', error);
            }
        }

        // Auto-resize chat input
        document.getElementById('aiChatInput').addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        });

        // Send message on Enter (but allow Shift+Enter for new lines)
        document.getElementById('aiChatInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendAIMessage();
            }
        });

        // Social Media Actions
        async function toggleComplete(itemId) {
            try {
                const item = feedItems.find(i => i.id === itemId);
                if (!item) {
                    console.error('Item not found:', itemId);
                    showToast('Item not found', 'error');
                    return;
                }
                
                const isCompleted = item.status === 'completed';
                const newStatus = isCompleted ? 'active' : 'completed';
                
                const updateData = { status: newStatus };
                
                if (newStatus === 'completed' && databaseSchema?.memoriesTableColumns) {
                    const today = new Date().toISOString().split('T')[0];
                    
                    if (databaseSchema.memoriesTableColumns.includes('completed_date')) {
                        updateData.completed_date = today;
                    }
                    if (databaseSchema.memoriesTableColumns.includes('completed')) {
                        updateData.completed = today;
                    }
                    // Don't send modified - server handles this automatically
                }
                
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (response.ok) {
                    const updatedItem = await response.json();
                    
                    // Update the local item with server response
                    Object.assign(item, updatedItem);
                    
                    if (newStatus === 'completed') {
                        // Remove the item from the feed when completed
                        const card = document.querySelector(`[data-item-id="${itemId}"]`);
                        if (card) {
                            // Animate removal
                            card.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                            card.style.opacity = '0';
                            card.style.transform = 'translateX(100%)';
                            
                            setTimeout(() => {
                                card.remove();
                                // Remove from feedItems array
                                feedItems = feedItems.filter(i => i.id !== itemId);
                                // Update counts
                                document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
                                document.getElementById('totalItemsCount').textContent = feedItems.length;
                            }, 300);
                        }
                        
                        showToast(`Completed! âœ… Task removed from active list`, 'success');
                    } else {
                        // If reactivating, update the button UI
                        const card = document.querySelector(`[data-item-id="${itemId}"]`);
                        if (card) {
                            const btn = card.querySelector('.action-btn .fa-check')?.parentElement;
                            if (btn) {
                                btn.classList.remove('completed');
                            }
                        }
                        showToast('Reactivated', 'success');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Failed to toggle complete:', response.status, errorText);
                    showToast('Failed to update status', 'error');
                }
            } catch (error) {
                console.error('Error toggling complete:', error);
                showToast('Error updating status', 'error');
            }
        }

        function shareItem(itemId) {
            const item = feedItems.find(i => i.id === itemId);
            if (!item) return;
            
            const text = `Check out my ${item.type}: ${item.content_short || item.content}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'MindOS Item',
                    text: text
                });
            } else {
                navigator.clipboard.writeText(text);
                showToast('Copied to clipboard!', 'success');
            }
        }

        async function deleteItem(itemId) {
            if (!confirm('Delete this item?')) return;
            
            try {
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    // Remove from feedItems array
                    feedItems = feedItems.filter(item => item.id !== itemId);
                    
                    // Remove card from DOM
                    const card = document.querySelector(`[data-item-id="${itemId}"]`);
                    if (card) {
                        card.remove();
                    }
                    
                    document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
                    document.getElementById('totalItemsCount').textContent = feedItems.length;
                    
                    showToast('Deleted', 'success');
                } else {
                    showToast('Failed to delete', 'error');
                }
            } catch (error) {
                console.error('Error deleting:', error);
                showToast('Error deleting item', 'error');
            }
        }

        // Header Actions
        async function refreshFeed() {
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.innerHTML = '';
            
            await loadInitialFeed();
            showToast('Feed refreshed!', 'success');
        }

        function showProfile() {
            showToast('Profile coming soon!', 'info');
        }

        function logout() {
            localStorage.removeItem('mindos_token');
            authToken = null;
            currentUser = null;
            feedItems = [];
            
            document.getElementById('feedContainer').style.display = 'none';
            document.getElementById('loginScreen').style.display = 'flex';
            showLogin();
            
            showToast('Logged out', 'success');
        }

        // Utility Functions
        function showToast(message, type = 'info') {
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => toast.remove());
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            
            if (type === 'error') {
                toast.style.background = 'rgba(244, 67, 54, 0.9)';
            } else if (type === 'success') {
                toast.style.background = 'rgba(76, 175, 80, 0.9)';
            } else if (type === 'warning') {
                toast.style.background = 'rgba(255, 152, 0, 0.9)';
            }
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Global debug functions for testing
        window.debugEditMode = function() {
            debugMode = !debugMode;
            console.log('ðŸ› Debug mode:', debugMode ? 'ENABLED' : 'DISABLED');
            if (debugMode) {
                console.log('Use: debugEditItem(itemId) to debug a specific item');
            }
        };
        
        // Debug completion function
        window.debugCompletion = async function(itemId) {
            console.log('ðŸ” Testing completion for item:', itemId);
            
            if (!authToken) {
                console.error('âŒ Not logged in!');
                return;
            }
            
            try {
                console.log('ðŸ“¤ Sending completion request...');
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ status: 'completed' })
                });
                
                console.log('ðŸ“¥ Response status:', response.status);
                const responseText = await response.text();
                console.log('ðŸ“¥ Response:', responseText);
                
                if (response.ok) {
                    console.log('âœ… Success! Item marked as completed');
                    const data = JSON.parse(responseText);
                    console.log('Updated item:', data);
                } else {
                    console.error('âŒ Failed:', responseText);
                }
            } catch (error) {
                console.error('âŒ Error:', error);
            }
        };
        
        // List all items with IDs
        window.listItems = function() {
            console.log('ðŸ“‹ Your items:');
            feedItems.forEach((item, index) => {
                console.log(`${index + 1}. ID: ${item.id} - "${item.content_short || item.content}" (Status: ${item.status})`);
            });
            if (feedItems.length === 0) {
                console.log('No items found. Try refreshing the feed.');
            }
        };

        window.testEdit = async function(itemId) {
            console.log('ðŸ§ª Testing edit for item:', itemId);
            const item = feedItems.find(i => i.id == itemId);
            if (item) {
                console.log('Found item:', item);
                editItem(itemId);
            } else {
                console.log('Item not found. Available items:', feedItems.map(i => i.id));
            }
        };

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEdit();
                closeAIChat();
            }
            if (e.key === 'Home') {
                e.preventDefault();
                scrollToTop();
            }
        });

        // Touch/Swipe Support (simplified for continuous scroll)
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            const diff = touchStartY - touchEndY;
            
            // Only handle large swipes for special actions
            if (Math.abs(diff) > 100) {
                if (diff < -100) {
                    // Large upward swipe - go to top
                    scrollToTop();
                }
            }
        });
    </script>
</body>
</html>
