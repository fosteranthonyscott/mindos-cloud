<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindOS - Your Personal AI Feed</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
            height: 100vh;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        /* =========================
           LOGIN SCREEN 
        ========================= */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .login-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .logo {
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 2rem;
            color: white;
            font-size: 2rem;
        }

        .login-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .login-subtitle {
            color: #666;
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 2px solid #e0e6ff;
            border-radius: 12px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-bottom: 1rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .switch-mode {
            color: #667eea;
            cursor: pointer;
            text-decoration: underline;
        }

        /* =========================
           NEVER-ENDING FEED LAYOUT
        ========================= */
        .feed-container {
            display: none;
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
        }

        /* Fixed Header */
        .feed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .mindos-logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
        }

        .user-info h3 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .user-info p {
            font-size: 0.9rem;
            color: #888;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .header-btn {
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .header-btn.add-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        /* IMPROVED: Never-ending Feed Scroll Container */
        .feed-scroll {
            height: 100vh;
            width: 100%;
            overflow-y: scroll;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-top: 80px;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        .feed-scroll::-webkit-scrollbar {
            display: none;
        }

        /* IMPROVED: Content-Responsive Feed Cards */
        .feed-card {
            min-height: 50vh; /* Minimum height for visual consistency */
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f4c75 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 2px;
            /* Let content determine actual height */
            height: auto;
        }

        .feed-card:nth-child(even) {
            background: linear-gradient(135deg, #2d1b69 0%, #11998e 50%, #38ef7d 100%);
        }

        .feed-card:nth-child(3n) {
            background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
        }

        /* Remove fixed height classes - cards expand based on content */
        .feed-card.compact,
        .feed-card.expanded {
            min-height: 50vh;
            height: auto;
        }

        /* For cards with extensive notes, ensure proper spacing */
        .feed-card.has-notes {
            padding-bottom: 2rem;
        }

        /* Card Content Area */
        .card-content-area {
            flex: 1;
            padding: 3rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Changed from center to allow natural flow */
            position: relative;
        }

        .card-type-badge {
            position: absolute;
            top: 2rem;
            left: 2rem;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-priority {
            position: absolute;
            top: 2rem;
            right: 2rem;
            font-size: 1.5rem;
            color: #ffd700;
        }

        .card-brain-logo {
            position: absolute;
            top: 50%;
            left: 2rem;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        .card-brain-logo:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
        }

        .card-main-content {
            text-align: center;
            max-width: 800px; /* Increased for better notes display */
            margin: 0 auto;
            width: 100%;
        }

        .card-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1.2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .card-description {
            font-size: 1.2rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
        }

        .card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Social Media Actions */
        .card-actions {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .action-btn.completed {
            background: #00d084;
            color: white;
        }

        .action-btn.ai-chat {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        /* NEW: Scroll Position Indicator */
        .scroll-indicator {
            position: fixed;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 900;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 1rem 0.5rem;
        }

        .scroll-indicator .current-item {
            font-size: 0.8rem;
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .scroll-indicator .total-items {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.5rem;
        }

        .scroll-progress {
            width: 4px;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            position: relative;
        }

        .scroll-progress-fill {
            width: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
            transition: height 0.3s ease;
            height: 0%;
        }

        /* NEW: End of Feed Message */
        .end-of-feed {
            min-height: 60vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2c1810 0%, #8b4513 100%);
            text-align: center;
            padding: 4rem 2rem;
        }

        .end-of-feed .brain-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            margin-bottom: 2rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .end-of-feed h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

        .end-of-feed p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.8);
            max-width: 500px;
            line-height: 1.6;
        }

        .end-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .end-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .end-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        /* Loading more items indicator */
        .loading-more {
            padding: 2rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* =========================
           EDIT/QUICK ADD OVERLAY - UNIFIED STYLING
        ========================= */
        .edit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 2rem;
        }

        .edit-overlay.show {
            display: flex;
        }

        .edit-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .edit-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .edit-input {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .edit-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .edit-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        /* ENHANCED: Improved select dropdown styling for better visibility */
        .edit-input select {
            background: rgba(0, 0, 0, 0.8) !important;
            color: white !important;
            border: 1px solid rgba(255, 255, 255, 0.3);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1rem;
            padding-right: 3rem;
        }

        .edit-input select option {
            background: rgba(0, 0, 0, 0.95) !important;
            color: white !important;
            padding: 0.5rem;
            border: none;
        }

        .edit-input select option:hover,
        .edit-input select option:checked,
        .edit-input select option:focus {
            background: rgba(102, 126, 234, 0.8) !important;
            color: white !important;
        }

        .edit-input select option[value=""] {
            color: rgba(255, 255, 255, 0.7) !important;
            font-style: italic;
        }

        .edit-input select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
            background: rgba(0, 0, 0, 0.9) !important;
        }

        /* UNIFIED: Core fields styling for both add and edit */
        .core-fields {
            margin-bottom: 2rem;
        }

        .optional-fields {
            margin-bottom: 1rem;
        }

        .optional-fields.collapsed {
            display: none;
        }

        .field-controls {
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .field-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 0.5rem;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .field-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .available-fields {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            display: none;
        }

        .available-fields.show {
            display: block;
        }

        .field-tag {
            display: inline-block;
            background: rgba(102, 126, 234, 0.3);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            margin: 0.2rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .field-tag:hover {
            background: rgba(102, 126, 234, 0.5);
        }

        .field-tag.added {
            background: rgba(76, 175, 80, 0.3);
        }

        .field-remove-btn {
            background: rgba(244, 67, 54, 0.3);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            margin-left: 0.5rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .field-remove-btn:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .edit-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .edit-btn {
            flex: 1;
            padding: 1rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .edit-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .edit-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Data validation feedback */
        .validation-error {
            border-color: #f44336 !important;
            box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.3) !important;
        }

        .validation-message {
            color: #f44336;
            font-size: 0.8rem;
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
        }

        /* =========================
           AI CHAT INTERFACE - COMMENT BUBBLE STYLE
        ========================= */
        /* Comment Bubble Container - positioned at bottom of each card */
        .ai-comment-bubble {
            position: absolute;
            bottom: 120px;
            right: 20px;
            max-width: 400px;
            background: rgba(30, 30, 40, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            max-height: 60vh;
            z-index: 100;
            border: 1px solid rgba(102, 126, 234, 0.3);
            overflow: hidden;
            animation: bubbleSlideIn 0.3s ease-out;
        }

        @keyframes bubbleSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .ai-comment-bubble.show {
            display: flex;
        }

        /* Bubble Header - Simplified */
        .bubble-header {
            padding: 1rem;
            background: rgba(102, 126, 234, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: move;
        }

        .bubble-header-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .bubble-header-title .brain-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .bubble-actions {
            display: flex;
            gap: 0.5rem;
        }

        .bubble-action-btn {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .bubble-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .bubble-action-btn.pin-btn.pinned {
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        /* Quick Actions Bar */
        .bubble-quick-actions {
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .quick-action-chip {
            padding: 0.4rem 0.8rem;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .quick-action-chip:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-2px);
        }

        .quick-action-chip.suggested {
            background: rgba(76, 175, 80, 0.2);
            border-color: rgba(76, 175, 80, 0.3);
        }

        /* Messages Container - Compact */
        .bubble-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            min-height: 200px;
            max-height: 350px;
        }

        .bubble-message {
            display: flex;
            gap: 0.5rem;
            max-width: 90%;
            animation: messageSlideIn 0.3s ease-out;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .bubble-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .bubble-message.assistant {
            align-self: flex-start;
        }

        .bubble-message-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
            flex-shrink: 0;
        }

        .bubble-message.user .bubble-message-avatar {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .bubble-message.assistant .bubble-message-avatar {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .bubble-message-content {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 0.6rem 1rem;
            font-size: 0.85rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .bubble-message.user .bubble-message-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .bubble-message.system .bubble-message-content {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.3);
            font-size: 0.8rem;
        }

        /* Input Area - Compact */
        .bubble-input-container {
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bubble-input-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .bubble-input {
            flex: 1;
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: white;
            font-size: 0.85rem;
            resize: none;
            min-height: 36px;
            max-height: 80px;
        }

        .bubble-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .bubble-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
        }

        .bubble-send {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .bubble-send:hover {
            transform: scale(1.1);
        }

        .bubble-send:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Minimize/Expand States */
        .ai-comment-bubble.minimized {
            height: 50px;
            overflow: hidden;
        }

        .ai-comment-bubble.minimized .bubble-messages,
        .ai-comment-bubble.minimized .bubble-input-container,
        .ai-comment-bubble.minimized .bubble-quick-actions {
            display: none;
        }

        /* Pinned Insights Panel */
        .pinned-insights-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 300px;
            max-height: 60vh;
            background: rgba(30, 30, 40, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            border: 1px solid rgba(255, 193, 7, 0.3);
            display: none;
            flex-direction: column;
            z-index: 900;
            animation: fadeIn 0.3s ease-out;
        }

        .pinned-insights-panel.show {
            display: flex;
        }

        .pinned-insights-header {
            padding: 1rem;
            background: rgba(255, 193, 7, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .pinned-insights-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .pinned-insight {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            position: relative;
            border: 1px solid rgba(255, 193, 7, 0.2);
        }

        .pinned-insight-remove {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 20px;
            height: 20px;
            background: rgba(244, 67, 54, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* OLD CHAT OVERLAY - TO BE REMOVED */
        .ai-chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            z-index: 3000;
        }

        .ai-chat-overlay.show {
            display: flex;
            flex-direction: column;
        }

        .ai-chat-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ai-chat-title {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .ai-chat-title .brain-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
        }

        .ai-chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .ai-message {
            display: flex;
            gap: 1rem;
            max-width: 80%;
        }

        .ai-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .ai-message.assistant {
            align-self: flex-start;
        }

        .ai-message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .ai-message.user .ai-message-avatar {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .ai-message.assistant .ai-message-avatar {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .ai-message-content {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1rem;
            word-wrap: break-word;
        }

        .ai-message.user .ai-message-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .ai-chat-input-container {
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ai-chat-input-wrapper {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .ai-chat-input {
            flex: 1;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            resize: none;
            min-height: 50px;
            max-height: 150px;
        }

        .ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .ai-chat-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .ai-chat-send {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.1);
        }

        .ai-chat-send:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Loading States */
        .loading {
            position: relative;
            color: transparent !important;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: rgba(255, 255, 255, 0.8);
            animation: spin 1s linear infinite;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            color: white;
            padding: 1rem 2rem;
            border-radius: 30px;
            font-weight: 600;
            z-index: 3000;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .feed-header {
                padding: 0 1rem;
            }
            
            .card-title {
                font-size: 2rem;
            }
            
            .card-description {
                font-size: 1rem;
            }
            
            .card-content-area {
                padding: 1.5rem;
            }
            
            .card-actions {
                bottom: 1rem;
                right: 1rem;
            }
            
            .action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .card-brain-logo {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }

            .ai-chat-messages {
                padding: 1rem;
            }

            .ai-chat-input-container {
                padding: 1rem;
            }

            .scroll-indicator {
                right: 0.5rem;
                padding: 0.5rem 0.3rem;
            }

            .edit-input select option {
                font-size: 16px;
                padding: 0.75rem 0.5rem;
            }
        }
        /* Enhanced Notes Display Formatting - NO SCROLL, EXPANDABLE CARDS */
        .card-notes-container {
            text-align: left;
            margin: 2rem 0;
            padding: 2rem 2.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .notes-paragraph {
            font-size: 1.15rem;
            line-height: 2;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 1.5rem;
            letter-spacing: 0.02em;
        }

        .notes-paragraph:last-child {
            margin-bottom: 0;
        }

        .notes-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
            margin: 2rem 0 1.5rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid rgba(102, 126, 234, 0.2);
            letter-spacing: 0.03em;
        }

        .notes-title:first-child {
            margin-top: 0;
        }

        .notes-header {
            font-size: 1.5rem;
            font-weight: 600;
            color: #764ba2;
            margin: 2rem 0 1.2rem 0;
            letter-spacing: 0.02em;
        }

        .notes-subheader {
            font-size: 1.3rem;
            font-weight: 600;
            color: #f093fb;
            margin: 1.8rem 0 1rem 0;
            letter-spacing: 0.02em;
        }

        .notes-ordered-list,
        .notes-unordered-list {
            margin: 2rem 0;
            padding-left: 0;
            list-style: none;
        }

        .notes-numbered-item,
        .notes-bullet-item {
            position: relative;
            margin-bottom: 1.2rem;
            padding-left: 2.5rem;
            line-height: 1.9;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.01em;
        }

        .notes-numbered-item:last-child,
        .notes-bullet-item:last-child {
            margin-bottom: 0;
        }

        .notes-numbered-item .notes-number {
            position: absolute;
            left: 0;
            top: 0;
            color: #667eea;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .notes-bullet-item::before {
            content: "â€¢";
            position: absolute;
            left: 0.75rem;
            top: -0.1rem;
            color: #764ba2;
            font-size: 1.4rem;
            font-weight: bold;
        }

        .card-notes-container strong {
            color: #667eea;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .card-notes-container em {
            color: #f093fb;
            font-style: italic;
            letter-spacing: 0.01em;
        }

        .card-notes-container br {
            display: block;
            margin: 0.5rem 0;
        }

        /* Add visual breathing room between different types of content */
        .notes-ordered-list + .notes-paragraph,
        .notes-unordered-list + .notes-paragraph,
        .notes-paragraph + .notes-ordered-list,
        .notes-paragraph + .notes-unordered-list,
        .notes-header + .notes-paragraph,
        .notes-subheader + .notes-paragraph,
        .notes-title + .notes-paragraph {
            margin-top: 2rem;
        }

        /* Horizontal divider */
        .notes-divider {
            border: none;
            height: 2px;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
            margin: 2.5rem 0;
        }

        /* Adjust card main content for better notes display */
        .card-main-content {
            padding: 0.5rem 0;
        }

        /* Override default card title margin when notes are present */
        .card-title {
            margin-bottom: 0.5rem !important;
        }

        /* If notes container follows title, reduce top margin */
        .card-title + .card-notes-container {
            margin-top: 1rem;
        }

        /* Responsive adjustments for notes */
        @media (max-width: 768px) {
            .card-notes-container {
                padding: 1rem;
                margin: 1rem 0;
            }

            .notes-paragraph {
                font-size: 1rem;
                line-height: 1.6;
            }

            .notes-numbered-item,
            .notes-bullet-item {
                font-size: 0.95rem;
                padding-left: 1.5rem;
            }
        }

    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="login-card">
            <div class="logo">
                <i class="fas fa-brain"></i>
            </div>
            <h1 class="login-title">MindOS</h1>
            <p class="login-subtitle">Your Personal AI Assistant</p>
            
            <!-- Login Form -->
            <form id="loginForm" style="display: block;">
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit" class="btn" id="loginBtn">
                    <i class="fas fa-sign-in-alt"></i> Sign In
                </button>
                <p>Don't have an account? <span class="switch-mode" onclick="showRegister()">Sign up</span></p>
            </form>

            <!-- Register Form -->
            <form id="registerForm" style="display: none;">
                <div class="form-group">
                    <label for="regUsername">Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label for="regEmail">Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label for="regPassword">Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button type="submit" class="btn" id="registerBtn">
                    <i class="fas fa-user-plus"></i> Create Account
                </button>
                <p>Already have an account? <span class="switch-mode" onclick="showLogin()">Sign in</span></p>
            </form>
        </div>
    </div>

    <!-- Never-Ending Feed -->
    <div id="feedContainer" class="feed-container">
        <!-- Fixed Header -->
        <div class="feed-header">
            <div class="header-left">
                <div class="mindos-logo">
                    <i class="fas fa-brain"></i>
                </div>
                <div class="user-info">
                    <h3 id="feedUserName">Loading...</h3>
                    <p id="feedItemCount">0 items in feed</p>
                </div>
            </div>
            <div class="header-actions">
                <button class="header-btn add-btn" onclick="showAddItem()" title="Add New Item">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="header-btn" onclick="refreshFeed()" title="Refresh Feed">
                    <i class="fas fa-refresh"></i>
                </button>
                <button class="header-btn" onclick="scrollToTop()" title="Back to Top">
                    <i class="fas fa-arrow-up"></i>
                </button>
                <button class="header-btn" onclick="showProfile()" title="Profile">
                    <i class="fas fa-user"></i>
                </button>
                <button class="header-btn" onclick="logout()" title="Logout">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
            </div>
        </div>

        <!-- Scrollable Feed -->
        <div class="feed-scroll" id="feedScroll">
            <!-- Feed cards will be dynamically inserted here -->
        </div>

        <!-- Scroll Position Indicator -->
        <div class="scroll-indicator" id="scrollIndicator">
            <div class="current-item" id="currentItemNumber">1</div>
            <div class="scroll-progress">
                <div class="scroll-progress-fill" id="scrollProgressFill"></div>
            </div>
            <div class="total-items" id="totalItemsCount">0</div>
        </div>
    </div>

    <!-- UNIFIED Edit/Add Overlay -->
    <div id="editOverlay" class="edit-overlay">
        <div class="edit-card">
            <h2 class="edit-title" id="editTitle">Edit Item</h2>
            
            <!-- Core Fields - Used for both Add and Edit -->
            <div id="coreFields" class="core-fields">
                <!-- Essential fields will be inserted here -->
            </div>
            
            <!-- Field Management Controls - Hidden for Add mode -->
            <div class="field-controls" id="fieldControls">
                <button type="button" class="field-control-btn" onclick="toggleOptionalFields()">
                    <i class="fas fa-plus"></i> Add Fields
                </button>
                <button type="button" class="field-control-btn" onclick="toggleAvailableFields()">
                    <i class="fas fa-list"></i> Browse Fields
                </button>
            </div>
            
            <!-- Available Fields Picker -->
            <div id="availableFields" class="available-fields">
                <p style="margin-bottom: 1rem; font-size: 0.9rem;">Click to add fields:</p>
                <div id="fieldTags">
                    <!-- Field tags will be inserted here -->
                </div>
            </div>
            
            <!-- Optional Fields -->
            <div id="optionalFields" class="optional-fields collapsed">
                <!-- Additional fields will be inserted here -->
            </div>
            
            <div class="edit-actions">
                <button class="edit-btn secondary" onclick="closeEdit()">Cancel</button>
                <button class="edit-btn primary" onclick="saveEdit()" id="saveEditBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- AI Chat Overlay -->
    <div id="aiChatOverlay" class="ai-chat-overlay">
        <div class="ai-chat-header">
            <div class="ai-chat-title">
                <div class="brain-icon">
                    <i class="fas fa-brain"></i>
                </div>
                <div>
                    <h3 id="aiChatItemTitle">Chat with MindOS AI</h3>
                    <p id="aiChatItemType">About this item</p>
                </div>
            </div>
            <button class="header-btn" onclick="closeAIChat()" title="Close Chat">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="ai-chat-container">
            <div class="ai-chat-messages" id="aiChatMessages">
                <!-- Chat messages will be inserted here -->
            </div>
            
            <div class="ai-chat-input-container">
                <div class="ai-chat-input-wrapper">
                    <textarea 
                        id="aiChatInput" 
                        class="ai-chat-input" 
                        placeholder="Ask MindOS about this item, request changes, or get help..."
                        rows="1"
                    ></textarea>
                    <button id="aiChatSend" class="ai-chat-send" onclick="sendAIMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global State
        let currentUser = null;
        let authToken = localStorage.getItem('mindos_token');
        let feedItems = [];
        let currentEditItem = null;
        // AI Comment Bubble Interface Variables
        let currentAIItem = null;
        let aiChatHistory = [];
        let activeBubbles = new Map(); // Track open bubbles per item
        let pinnedInsights = []; // Store pinned insights
        let databaseSchema = null;
        let activeOptionalFields = new Set();
        let debugMode = false;
        let isAddMode = false; // UNIFIED: Replace isQuickAdd with isAddMode
        
        // NEW: Never-ending feed state
        let currentScrollPosition = 0;
        let isLoadingMore = false;
        let hasMoreItems = true;
        let currentPage = 0;
        const ITEMS_PER_PAGE = 10;

        // UPDATED: Unified field configuration
        const CORE_FIELDS = ['content', 'type', 'status', 'priority'];
        const BASIC_ADD_FIELDS = ['type', 'content', 'priority', 'due', 'status'];

        // ===== DROPDOWN VISIBILITY FIX =====
        // Multi-stage fix for dropdown color and visibility issues
        
        function fixDropdownVisibility() {
            console.log('ðŸ”§ Fixing dropdown visibility...');
            
            // Find all select elements in the edit overlay
            const selects = document.querySelectorAll('.edit-input select, #editOverlay select, .edit-overlay select');
            
            console.log(`Found ${selects.length} select elements to fix`);
            
            selects.forEach((select, index) => {
                console.log(`Fixing select ${index + 1}:`, select.id || 'unnamed');
                
                // Force dark background directly via JavaScript (this will override CSS)
                select.style.setProperty('background', 'rgba(0, 0, 0, 0.8)', 'important');
                select.style.setProperty('background-color', '#1a1a1a', 'important');
                select.style.setProperty('color', '#ffffff', 'important');
                select.style.setProperty('border', '2px solid #667eea', 'important');
                select.style.setProperty('font-size', '16px', 'important');
                
                // Also fix all option elements
                const options = select.querySelectorAll('option');
                options.forEach((option, optIndex) => {
                    option.style.setProperty('background-color', '#1a1a1a', 'important');
                    option.style.setProperty('background', '#1a1a1a', 'important');
                    option.style.setProperty('color', '#ffffff', 'important');
                    console.log(`  Fixed option ${optIndex + 1}: ${option.textContent}`);
                });
                
                // Add event listeners for better feedback
                select.addEventListener('focus', function() {
                    this.style.setProperty('background', 'rgba(0, 0, 0, 0.9)', 'important');
                    this.style.setProperty('border-color', '#667eea', 'important');
                    console.log('Select focused:', this.id);
                });
                
                select.addEventListener('change', function() {
                    console.log('Select changed to:', this.value, this.options[this.selectedIndex].text);
                    // Flash effect to confirm selection
                    this.style.setProperty('border-color', '#00ff88', 'important');
                    setTimeout(() => {
                        this.style.setProperty('border-color', '#667eea', 'important');
                    }, 300);
                });
            });
        }

        // Observer to catch any dynamically added selects
        const dropdownObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    const addedSelects = [];
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            if (node.tagName === 'SELECT') {
                                addedSelects.push(node);
                            }
                            const childSelects = node.querySelectorAll ? node.querySelectorAll('select') : [];
                            addedSelects.push(...childSelects);
                        }
                    });
                    
                    if (addedSelects.length > 0) {
                        console.log('ðŸ” Detected new select elements, fixing...');
                        setTimeout(fixDropdownVisibility, 50);
                    }
                }
            });
        });

        // Manual trigger function for testing
        window.debugFixDropdowns = function() {
            console.log('ðŸ› Manual dropdown fix triggered');
            fixDropdownVisibility();
        };

        // Initialize App
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ðŸš€ MindOS AI-Powered Never-Ending Feed Starting...');
            
            // Start observing the edit overlay for dropdown fixes
            const editOverlay = document.getElementById('editOverlay');
            if (editOverlay) {
                dropdownObserver.observe(editOverlay, {
                    childList: true,
                    subtree: true
                });
            }
            
            if (authToken) {
                const isValid = await validateToken();
                if (isValid) {
                    await loadDatabaseSchema();
                    showFeed();
                    return;
                }
            }
            
            showLogin();
        });

        // Authentication Functions
        function showLogin() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
        }

        function showRegister() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
        }

        async function validateToken() {
            try {
                const response = await fetch('/api/user-status', {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentUser = data.user;
                    return true;
                }
            } catch (error) {
                console.error('Token validation failed:', error);
            }
            
            localStorage.removeItem('mindos_token');
            authToken = null;
            return false;
        }

        // Login Form Handler
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const btn = document.getElementById('loginBtn');
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('mindos_token', authToken);
                    
                    showToast('Welcome back!', 'success');
                    await loadDatabaseSchema();
                    showFeed();
                } else {
                    showToast(data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showToast('Network error. Please try again.', 'error');
                console.error('Login error:', error);
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });

        // Register Form Handler
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const btn = document.getElementById('registerBtn');
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;
            
            if (!username || !email || !password) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            if (password.length < 6) {
                showToast('Password must be at least 6 characters', 'error');
                return;
            }
            
            btn.classList.add('loading');
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('mindos_token', authToken);
                    
                    showToast('Account created successfully!', 'success');
                    await loadDatabaseSchema();
                    showFeed();
                } else {
                    showToast(data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showToast('Network error. Please try again.', 'error');
                console.error('Register error:', error);
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        });

        // ENHANCED: Load Database Schema with detailed analysis
        async function loadDatabaseSchema() {
            try {
                const response = await fetch('/api/debug/schema', {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    databaseSchema = await response.json();
                    console.log('ðŸ“Š Database schema loaded:', databaseSchema);
                    console.log('ðŸ“‹ Available columns:', databaseSchema.memoriesTableColumns);
                    
                    // Log column analysis for debugging
                    if (databaseSchema.memoriesTableColumns) {
                        console.log('ðŸ” Column analysis:');
                        console.log('  - Total columns:', databaseSchema.memoriesTableColumns.length);
                        console.log('  - Has type:', databaseSchema.hasTypeColumn);
                        console.log('  - Has content:', databaseSchema.hasContentColumn);
                        console.log('  - Has priority:', databaseSchema.hasPriorityColumn);
                    }
                } else {
                    console.error('Failed to load database schema');
                    showToast('Warning: Could not load database schema', 'warning');
                }
            } catch (error) {
                console.error('Error loading database schema:', error);
                showToast('Warning: Database schema unavailable', 'warning');
            }
        }

        // NEW: Never-Ending Feed Functions
        async function showFeed() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('feedContainer').style.display = 'block';
            
            if (currentUser) {
                document.getElementById('feedUserName').textContent = currentUser.username;
            }
            
            if (!databaseSchema) {
                await loadDatabaseSchema();
            }
            
            await loadInitialFeed();
            setupContinuousScrollListener();
        }

        async function loadInitialFeed() {
            feedItems = [];
            currentPage = 0;
            hasMoreItems = true;
            
            // Clear existing content
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.innerHTML = '';
            
            await loadMoreItems();
        }

        async function loadMoreItems() {
            if (isLoadingMore || !hasMoreItems) return;
            
            isLoadingMore = true;
            showLoadingIndicator();
            
            try {
                // Try enhanced endpoint first, fallback to basic
                // IMPORTANT: Exclude completed items from the feed
                const offset = currentPage * ITEMS_PER_PAGE;
                let response = await fetch(`/api/memories/enhanced?limit=${ITEMS_PER_PAGE}&offset=${offset}&sort_by=priority&sort_order=desc&exclude_completed=true`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                let data;
                if (response.ok) {
                    data = await response.json();
                } else {
                    // Fallback to basic endpoint
                    response = await fetch(`/api/memories?limit=${ITEMS_PER_PAGE}`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const memories = await response.json();
                        data = { memories: memories.slice(offset, offset + ITEMS_PER_PAGE) };
                    }
                }
                
                if (response.ok && data) {
                    const newItems = data.memories || [];
                    
                    if (newItems.length === 0) {
                        hasMoreItems = false;
                        showEndOfFeed();
                    } else {
                        feedItems = [...feedItems, ...newItems];
                        appendFeedCards(newItems);
                        currentPage++;
                        
                        // Check if we have more items
                        if (newItems.length < ITEMS_PER_PAGE) {
                            hasMoreItems = false;
                            showEndOfFeed();
                        }
                    }
                } else {
                    showToast('Error loading items', 'error');
                }
            } catch (error) {
                console.error('Error loading more items:', error);
                showToast('Network error loading items', 'error');
            } finally {
                isLoadingMore = false;
                hideLoadingIndicator();
                updateScrollIndicator();
            }
        }

        function appendFeedCards(items) {
            const feedScroll = document.getElementById('feedScroll');
            
            items.forEach((item, index) => {
                const card = createFeedCard(item, feedItems.indexOf(item));
                feedScroll.appendChild(card);
            });
            
            document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
            document.getElementById('totalItemsCount').textContent = feedItems.length;
        }

        // Format notes for better display with proper spacing and structure
        function formatNotesForDisplay(notes) {
            if (!notes) return '';
            
            // Pre-process to ensure better spacing
            let preprocessed = notes
                // Ensure double line breaks before headers
                .replace(/([^\n])\n(#{1,3} )/g, '$1\n\n$2')
                // Ensure double line breaks before lists
                .replace(/([^\n])\n(\d+\.\s|[-â€¢*]\s)/g, '$1\n\n$2')
                // Normalize multiple line breaks
                .replace(/\n{3,}/g, '\n\n');
            
            // Convert markdown-style formatting to HTML
            let formatted = preprocessed
                // Headers
                .replace(/^### (.+)$/gm, '<h4 class="notes-subheader">$1</h4>')
                .replace(/^## (.+)$/gm, '<h3 class="notes-header">$1</h3>')
                .replace(/^# (.+)$/gm, '<h2 class="notes-title">$1</h2>')
                
                // Lists - improved regex to capture the number/bullet properly
                .replace(/^(\d+\.)\s+(.+)$/gm, '<li class="notes-numbered-item"><span class="notes-number">$1</span>$2</li>')
                .replace(/^[-â€¢*]\s+(.+)$/gm, '<li class="notes-bullet-item">$1</li>')
                
                // Bold and italic
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                
                // Horizontal rules
                .replace(/^---+$/gm, '<hr class="notes-divider">')
                
                // Line breaks - improved handling
                .replace(/\n\n+/g, '</p><p class="notes-paragraph">')
                .replace(/\n/g, '<br>');
            
            // Wrap consecutive list items
            formatted = formatted.replace(/(<li class="notes-numbered-item">.*?<\/li>)(\s*<li class="notes-numbered-item">)/g, function(match, p1, p2) {
                return p1 + p2;
            });
            
            formatted = formatted.replace(/(<li class="notes-bullet-item">.*?<\/li>)(\s*<li class="notes-bullet-item">)/g, function(match, p1, p2) {
                return p1 + p2;
            });
            
            // Wrap lists properly
            formatted = formatted.replace(/(<li class="notes-numbered-item">.*?<\/li>(?:\s*<li class="notes-numbered-item">.*?<\/li>)*)/g, function(match) {
                return '<ol class="notes-ordered-list">' + match + '</ol>';
            });
            
            formatted = formatted.replace(/(<li class="notes-bullet-item">.*?<\/li>(?:\s*<li class="notes-bullet-item">.*?<\/li>)*)/g, function(match) {
                return '<ul class="notes-unordered-list">' + match + '</ul>';
            });
            
            // Wrap content in paragraphs if needed
            if (!formatted.includes('<p') && !formatted.includes('<h') && !formatted.includes('<ul') && !formatted.includes('<ol')) {
                formatted = '<p class="notes-paragraph">' + formatted + '</p>';
            }
            
            // Clean up empty paragraphs
            formatted = formatted
                .replace(/<p class="notes-paragraph">\s*<\/p>/g, '')
                .replace(/<p class="notes-paragraph">(<h[1-6])/g, '$1')
                .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
                .replace(/<p class="notes-paragraph">(<ul|<ol)/g, '$1')
                .replace(/(<\/ul>|<\/ol>)<\/p>/g, '$1');
            
            return formatted;
        }

        function createFeedCard(item, index) {
            const card = document.createElement('div');
            card.className = 'feed-card';
            card.dataset.index = index;
            card.dataset.itemId = item.id;
            
            // Add has-notes class if notes exist
            if (item.notes && item.notes.trim().length > 0) {
                card.classList.add('has-notes');
            }
            
            const priority = parseInt(item.priority) || 1;
            const priorityStars = 'â˜…'.repeat(priority);
            
            const typeColors = {
                routine: '#667eea',
                goal: '#764ba2',
                task: '#f093fb',
                note: '#4facfe',
                preference: '#43e97b',
                insight: '#fa709a'
            };
            
            card.innerHTML = `
                <div class="card-content-area">
                    <div class="card-type-badge" style="background: ${typeColors[item.type] || '#667eea'};">
                        ${item.type || 'item'}
                    </div>
                    <div class="card-priority">${priorityStars}</div>
                    
                    <div class="card-main-content">
                        <h2 class="card-title">${item.content_short || (item.content ? item.content.substring(0, 100) : 'Untitled')}</h2>
                        ${item.notes ? `
                            <div class="card-notes-container">
                                ${formatNotesForDisplay(item.notes)}
                            </div>
                        ` : `
                            <p class="card-description">${item.content ? item.content.substring(100, 300) : 'No additional details'}</p>
                        `}
                        
                        <div class="card-meta">
                            <span>Status: ${item.status || 'active'}</span>
                            <span>${item.routine_type || ''}</span>
                        </div>
                    </div>
                </div>
                
                <div class="card-actions">
                    <button class="action-btn ai-chat" onclick="toggleAIBubble(${item.id})" title="AI Assistant">
                        <i class="fas fa-brain"></i>
                    </button>
                    
                    <button class="action-btn ${item.status === 'completed' ? 'completed' : ''}" onclick="toggleComplete(${item.id})" title="Mark Complete">
                        <i class="fas fa-check"></i>
                    </button>
                    
                    <button class="action-btn" onclick="editItem(${item.id})" title="Edit Item">
                        <i class="fas fa-edit"></i>
                    </button>
                    
                    <button class="action-btn" onclick="shareItem(${item.id})" title="Share Item">
                        <i class="fas fa-share"></i>
                    </button>
                    
                    <button class="action-btn" onclick="deleteItem(${item.id})" title="Delete Item">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            return card;
        }

        function showLoadingIndicator() {
            const feedScroll = document.getElementById('feedScroll');
            const existingLoader = document.getElementById('loadingMore');
            
            if (!existingLoader) {
                const loader = document.createElement('div');
                loader.id = 'loadingMore';
                loader.className = 'loading-more';
                loader.innerHTML = `
                    <div class="loading-spinner"></div>
                    <p>Loading more items...</p>
                `;
                feedScroll.appendChild(loader);
            }
        }

        function hideLoadingIndicator() {
            const loader = document.getElementById('loadingMore');
            if (loader) {
                loader.remove();
            }
        }

        function showEndOfFeed() {
            const feedScroll = document.getElementById('feedScroll');
            const existingEnd = document.getElementById('endOfFeed');
            
            if (!existingEnd && feedItems.length > 0) {
                const endCard = document.createElement('div');
                endCard.id = 'endOfFeed';
                endCard.className = 'end-of-feed';
                endCard.innerHTML = `
                    <div class="brain-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <h2>You've reached the end!</h2>
                    <p>Great job staying on top of your tasks and goals. You've reviewed all ${feedItems.length} items in your MindOS feed.</p>
                    
                    <div class="end-actions">
                        <button class="end-btn" onclick="scrollToTop()">
                            <i class="fas fa-arrow-up"></i> Back to Top
                        </button>
                        <button class="end-btn" onclick="showAddItem()">
                            <i class="fas fa-plus"></i> Add New Item
                        </button>
                        <button class="end-btn" onclick="refreshFeed()">
                            <i class="fas fa-refresh"></i> Refresh Feed
                        </button>
                    </div>
                `;
                feedScroll.appendChild(endCard);
            }
        }

        // NEW: Continuous Scroll Management
        function setupContinuousScrollListener() {
            const feedScroll = document.getElementById('feedScroll');
            
            feedScroll.addEventListener('scroll', () => {
                updateScrollIndicator();
                
                // Load more items when near bottom
                const scrollHeight = feedScroll.scrollHeight;
                const scrollTop = feedScroll.scrollTop;
                const clientHeight = feedScroll.clientHeight;
                
                if (scrollHeight - scrollTop - clientHeight < 1000) {
                    loadMoreItems();
                }
            });
        }

        function updateScrollIndicator() {
            const feedScroll = document.getElementById('feedScroll');
            const scrollPercentage = (feedScroll.scrollTop / (feedScroll.scrollHeight - feedScroll.clientHeight)) * 100;
            
            document.getElementById('scrollProgressFill').style.height = `${Math.max(0, Math.min(100, scrollPercentage))}%`;
            
            // Calculate current item based on scroll position
            const cards = document.querySelectorAll('.feed-card');
            let currentItem = 1;
            
            cards.forEach((card, index) => {
                const rect = card.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    currentItem = index + 1;
                }
            });
            
            document.getElementById('currentItemNumber').textContent = currentItem;
        }

        function scrollToTop() {
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // ===== ENHANCED DATA FORMATTING FUNCTIONS =====

        // NEW: Get database column types and constraints
        async function getTableStructure() {
            try {
                // If we have schema info, use it
                if (databaseSchema && databaseSchema.memoriesTableColumns) {
                    return {
                        columns: databaseSchema.memoriesTableColumns,
                        types: await getColumnTypes()
                    };
                }
                
                // Fallback to a basic set of known columns
                return {
                    columns: ['id', 'user_id', 'type', 'content', 'content_short', 'priority', 'status', 'created_at'],
                    types: {}
                };
            } catch (error) {
                console.error('Error getting table structure:', error);
                return { columns: [], types: {} };
            }
        }

        // NEW: Get column data types from server
        async function getColumnTypes() {
            try {
                // This would ideally come from a dedicated endpoint, 
                // but we'll infer from common patterns
                return {
                    'id': 'integer',
                    'user_id': 'string',
                    'type': 'string',
                    'content': 'text',
                    'content_short': 'string',
                    'priority': 'integer',
                    'status': 'string',
                    'due': 'date',
                    'created_at': 'timestamp',
                    'modified': 'date',
                    'completed_date': 'date',
                    'performance_streak': 'integer',
                    'required_time': 'string'
                };
            } catch (error) {
                console.error('Error getting column types:', error);
                return {};
            }
        }

        // ===== UNIFIED EDIT/ADD FUNCTIONS =====
        
        function getAvailableFields() {
            if (!databaseSchema || !databaseSchema.memoriesTableColumns) {
                return ['content', 'notes', 'type', 'status', 'priority', 'due', 'routine_type', 'goal_type'];
            }
            
            const excludeFields = ['id', 'user_id', 'created_at'];
            return databaseSchema.memoriesTableColumns.filter(col => !excludeFields.includes(col));
        }

        function createFieldElement(fieldName, value = '', isCore = false) {
            const fieldId = `edit_${fieldName}`;
            const label = fieldName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            const selectFields = {
                'type': ['routine', 'goal', 'task', 'note', 'preference', 'insight', 'event'],
                'status': ['active', 'completed', 'paused', 'archived'],
                'priority': [
                    { value: 1, label: 'Low Priority' },
                    { value: 2, label: 'Medium Priority' },
                    { value: 3, label: 'Normal Priority' },
                    { value: 4, label: 'High Priority' },
                    { value: 5, label: 'Critical Priority' }
                ],
                'stage': ['planning', 'in_progress', 'review', 'completed', 'on_hold'],
                'routine_type': ['morning', 'evening', 'daily', 'weekly', 'workout', 'health'],
                'goal_type': ['personal', 'professional', 'health', 'financial', 'learning']
            };
            
            const textAreaFields = ['content', 'notes', 'success_criteria', 'description'];
            const numberFields = ['performance_streak', 'required_time_minutes', 'priority'];
            const dateFields = ['due', 'modified', 'completed_date', 'target_date'];
            
            let inputHTML = '';
            
            if (selectFields[fieldName]) {
                const options = selectFields[fieldName];
                let optionsHTML = `<option value="">Select ${label}</option>`;
                
                if (Array.isArray(options) && typeof options[0] === 'object') {
                    optionsHTML += options.map(opt => 
                        `<option value="${opt.value}" ${value == opt.value ? 'selected' : ''}>${opt.label}</option>`
                    ).join('');
                } else {
                    optionsHTML += options.map(opt => 
                        `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt.charAt(0).toUpperCase() + opt.slice(1)}</option>`
                    ).join('');
                }
                
                inputHTML = `<select id="${fieldId}" class="edit-input">${optionsHTML}</select>`;
            } else if (textAreaFields.includes(fieldName)) {
                inputHTML = `<textarea id="${fieldId}" class="edit-input" rows="4" placeholder="${label}">${value || ''}</textarea>`;
            } else if (numberFields.includes(fieldName)) {
                inputHTML = `<input type="number" id="${fieldId}" class="edit-input" placeholder="${label}" value="${value || ''}">`;
            } else if (dateFields.includes(fieldName)) {
                const dateValue = value ? value.split('T')[0] : '';
                inputHTML = `<input type="date" id="${fieldId}" class="edit-input" value="${dateValue}">`;
            } else {
                inputHTML = `<input type="text" id="${fieldId}" class="edit-input" placeholder="${label}" value="${value || ''}">`;
            }
            
            const removeBtn = isCore ? '' : `<button type="button" class="field-remove-btn" onclick="removeField('${fieldName}')" title="Remove field">Ã—</button>`;
            
            return `
                <div class="form-group" data-field="${fieldName}">
                    <label for="${fieldId}">${label} ${removeBtn}</label>
                    ${inputHTML}
                </div>
            `;
        }

        // ENHANCED: Field value formatting function
        function formatFieldValue(fieldName, value) {
            if (value === null || value === undefined || value === '') {
                return null;
            }
            
            // Field-specific formatting
            switch (fieldName) {
                case 'priority':
                case 'performance_streak':
                case 'required_time_minutes':
                    const numVal = parseInt(value);
                    return isNaN(numVal) ? null : numVal;
                    
                case 'due':
                case 'completed_date':
                case 'target_date':
                    if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) {
                        return value.split('T')[0]; // Ensure date format
                    }
                    return value;
                    
                case 'content':
                case 'notes':
                    // Ensure content_short is generated if not provided
                    const trimmed = String(value).trim();
                    if (fieldName === 'content' && trimmed.length > 100) {
                        // Auto-generate content_short if not already provided
                        const shortContent = trimmed.substring(0, 97) + '...';
                        // This will be handled separately, just return the full content
                    }
                    return trimmed;
                    
                case 'type':
                case 'status':
                case 'routine_type':
                case 'goal_type':
                case 'stage':
                    return String(value).trim().toLowerCase();
                    
                default:
                    return typeof value === 'string' ? value.trim() : value;
            }
        }

        // ENHANCED: Debug function for troubleshooting edits
        async function debugEditItem(itemId) {
            if (!debugMode) {
                console.log('Enable debug mode first: debugMode = true');
                return;
            }
            
            try {
                console.log('ðŸ› Debug analysis for item:', itemId);
                
                const response = await fetch(`/api/debug/memory/${itemId}`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    const debug = await response.json();
                    console.log('ðŸ› Debug results:', debug);
                    
                    console.table({
                        'Memory ID': debug.memory.id,
                        'Content': debug.memory.content?.substring(0, 50) + '...',
                        'Type': debug.memory.type,
                        'Status': debug.memory.status,
                        'Priority': debug.memory.priority,
                        'User ID': debug.memory.user_id
                    });
                    
                    console.log('ðŸ“‹ Available columns:', debug.schema.availableColumns);
                    console.log('ðŸ” Analysis:', debug.analysis);
                    
                    return debug;
                } else {
                    console.error('Debug request failed:', response.status);
                }
            } catch (error) {
                console.error('Debug error:', error);
            }
        }

        // ENHANCED: Build form for both add and edit modes - WITH DROPDOWN FIX INTEGRATION
        function buildEditForm(item, isAdd = false) {
            console.log('ðŸ—ï¸ Building edit form, isAdd:', isAdd);
            console.log('ðŸ“‹ Item data:', item);
            
            const coreContainer = document.getElementById('coreFields');
            const optionalContainer = document.getElementById('optionalFields');
            const availableContainer = document.getElementById('fieldTags');
            const fieldControls = document.getElementById('fieldControls');
            const editTitle = document.getElementById('editTitle');
            const saveBtn = document.getElementById('saveEditBtn');
            
            // Set mode
            isAddMode = isAdd;
            activeOptionalFields.clear();
            
            console.log(`ðŸ”§ Building form - Add mode: ${isAddMode}`);
            
            // Update UI for mode
            if (isAddMode) {
                editTitle.textContent = 'Add New Item';
                saveBtn.textContent = 'Create Item';
                fieldControls.style.display = 'block';
            } else {
                editTitle.textContent = `Edit Item #${item.id}`;
                saveBtn.textContent = 'Save Changes';
                fieldControls.style.display = 'block';
            }
            
            // Get available fields from schema
            const availableFields = getAvailableFields();
            console.log('ðŸ“‹ Available fields from schema:', availableFields);
            
            // Build core fields
            let coreHTML = '';
            const fieldsToShow = isAddMode ? BASIC_ADD_FIELDS : CORE_FIELDS;
            
            fieldsToShow.forEach(fieldName => {
                if (availableFields.includes(fieldName)) {
                    const value = item[fieldName] || '';
                    console.log(`ðŸ”§ Building core field ${fieldName} with value:`, value);
                    coreHTML += createFieldElement(fieldName, value, true);
                }
            });
            coreContainer.innerHTML = coreHTML;
            
            // Clear optional fields
            optionalContainer.innerHTML = '';
            optionalContainer.classList.add('collapsed');
            
            // Build available fields tags
            let tagsHTML = '';
            availableFields.forEach(fieldName => {
                if (!fieldsToShow.includes(fieldName)) {
                    const hasValue = item[fieldName] !== null && item[fieldName] !== undefined && item[fieldName] !== '';
                    const tagClass = hasValue ? 'field-tag added' : 'field-tag';
                    const label = fieldName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    tagsHTML += `<span class="${tagClass}" data-field="${fieldName}" onclick="addField('${fieldName}')">${label}</span>`;
                    
                    if (hasValue) {
                        activeOptionalFields.add(fieldName);
                    }
                }
            });
            availableContainer.innerHTML = tagsHTML;
            
            // Auto-show optional fields if any have values (for edit mode)
            if (!isAddMode && activeOptionalFields.size > 0) {
                showOptionalFieldsWithValues(item);
            }
            
            // Apply dropdown fix after form is built
            setTimeout(fixDropdownVisibility, 150);
            
            console.log('âœ… Form built successfully');
        }

        function showOptionalFieldsWithValues(item) {
            const optionalContainer = document.getElementById('optionalFields');
            let optionalHTML = '';
            
            activeOptionalFields.forEach(fieldName => {
                optionalHTML += createFieldElement(fieldName, item[fieldName], false);
            });
            
            optionalContainer.innerHTML = optionalHTML;
            optionalContainer.classList.remove('collapsed');
            
            // Fix dropdowns in optional fields too
            setTimeout(fixDropdownVisibility, 100);
        }

        function toggleOptionalFields() {
            const optionalContainer = document.getElementById('optionalFields');
            optionalContainer.classList.toggle('collapsed');
        }

        function toggleAvailableFields() {
            const availableContainer = document.getElementById('availableFields');
            availableContainer.classList.toggle('show');
        }

        function addField(fieldName) {
            if (activeOptionalFields.has(fieldName)) {
                const fieldElement = document.querySelector(`[data-field="${fieldName}"]`);
                if (fieldElement) {
                    fieldElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return;
            }
            
            activeOptionalFields.add(fieldName);
            
            const tag = document.querySelector(`[data-field="${fieldName}"]`);
            if (tag) {
                tag.classList.add('added');
            }
            
            const optionalContainer = document.getElementById('optionalFields');
            const fieldHTML = createFieldElement(fieldName, currentEditItem[fieldName], false);
            optionalContainer.insertAdjacentHTML('beforeend', fieldHTML);
            
            optionalContainer.classList.remove('collapsed');
            
            // Fix any new dropdowns that were added
            setTimeout(fixDropdownVisibility, 50);
            
            showToast(`Added ${fieldName.replace(/_/g, ' ')} field`, 'success');
        }

        function removeField(fieldName) {
            const fieldsToShow = isAddMode ? BASIC_ADD_FIELDS : CORE_FIELDS;
            if (fieldsToShow.includes(fieldName)) {
                showToast('Cannot remove essential field', 'error');
                return;
            }
            
            activeOptionalFields.delete(fieldName);
            
            const fieldElement = document.querySelector(`[data-field="${fieldName}"]`);
            if (fieldElement) {
                fieldElement.remove();
            }
            
            const tag = document.querySelector(`span[data-field="${fieldName}"]`);
            if (tag) {
                tag.classList.remove('added');
            }
            
            showToast(`Removed ${fieldName.replace(/_/g, ' ')} field`, 'success');
        }

        // UNIFIED: Show Add Item (replaces showQuickAdd) - WITH DROPDOWN FIX INTEGRATION
        function showAddItem() {
            console.log('âž• Showing add item form');
            
            const emptyItem = {
                type: 'task',
                content: '',
                priority: 3,
                due: '',
                status: 'active'
            };
            
            currentEditItem = emptyItem;
            buildEditForm(emptyItem, true); // true = add mode
            document.getElementById('editOverlay').classList.add('show');
            
            // Apply dropdown fix after overlay is shown
            setTimeout(fixDropdownVisibility, 150);
        }

        // ENHANCED: Edit function with better error handling
        function editItem(itemId) {
            console.log('ðŸ“ Editing item:', itemId);
            
            // ENSURE ID IS PROPERLY CONVERTED
            const numericId = parseInt(itemId);
            if (isNaN(numericId)) {
                showToast('Invalid item ID', 'error');
                return;
            }
            
            const item = feedItems.find(i => i.id == numericId); // Use == for type coercion
            if (!item) {
                console.error('âŒ Item not found in feedItems:', numericId);
                console.log('ðŸ“‹ Available items:', feedItems.map(i => ({ id: i.id, type: typeof i.id })));
                showToast('Item not found', 'error');
                return;
            }
            
            console.log('ðŸ“ Found item for editing:', item);
            currentEditItem = item;
            buildEditForm(item, false); // false = edit mode
            document.getElementById('editOverlay').classList.add('show');
            
            // Apply dropdown fix after overlay is shown
            setTimeout(fixDropdownVisibility, 150);
        }

        function closeEdit() {
            document.getElementById('editOverlay').classList.remove('show');
            document.getElementById('availableFields').classList.remove('show');
            currentEditItem = null;
            activeOptionalFields.clear();
            isAddMode = false;
        }

        // ENHANCED SAVE FUNCTION WITH BETTER ERROR HANDLING AND DEBUGGING
        async function saveEdit() {
            if (!currentEditItem) {
                showToast('No item to save', 'error');
                return;
            }
            
            console.log('ðŸ’¾ Starting enhanced save process');
            console.log('ðŸ“‹ Current edit item:', currentEditItem);
            console.log('ðŸ”§ Add mode:', isAddMode);
            
            // Get button reference and original text BEFORE try block
            const saveBtn = document.getElementById('saveEditBtn');
            const originalText = saveBtn ? saveBtn.textContent : 'Save Changes';
            
            try {
                // Collect form data with better validation
                const rawData = {};
                const allInputs = document.querySelectorAll('#coreFields input, #coreFields textarea, #coreFields select, #optionalFields input, #optionalFields textarea, #optionalFields select');
                
                console.log(`ðŸ“Š Found ${allInputs.length} form inputs`);
                
                allInputs.forEach(input => {
                    const fieldName = input.id.replace('edit_', '');
                    let value = input.value;
                    
                    // Handle different input types
                    if (input.type === 'number') {
                        value = value === '' ? null : Number(value);
                    } else if (input.type === 'date') {
                        value = value === '' ? null : value;
                    } else if (input.tagName === 'SELECT') {
                        value = value === '' ? null : value;
                    } else {
                        value = value.trim();
                        if (value === '') value = null;
                    }
                    
                    rawData[fieldName] = value;
                    console.log(`ðŸ“ Raw field ${fieldName}:`, value, `(type: ${typeof value})`);
                });
                
                // ENHANCED: Validate essential fields
                const validationErrors = [];
                
                if (!rawData.content || (typeof rawData.content === 'string' && rawData.content.trim() === '')) {
                    validationErrors.push('Content is required');
                }
                
                if (isAddMode && (!rawData.type || rawData.type.trim() === '')) {
                    validationErrors.push('Type is required for new items');
                }
                
                if (validationErrors.length > 0) {
                    showToast(`Validation errors: ${validationErrors.join(', ')}`, 'error');
                    return;
                }
                
                // ENHANCED: Data formatting specific to database expectations
                const formattedData = {};
                
                Object.entries(rawData).forEach(([key, value]) => {
                    // Skip system fields
                    if (['id', 'user_id', 'created_at'].includes(key)) {
                        return;
                    }
                    
                    // Format based on field type
                    formattedData[key] = formatFieldValue(key, value);
                });
                
                console.log('ðŸŽ¯ Formatted data for submission:', formattedData);
                
                // Show loading state
                if (saveBtn) {
                    saveBtn.textContent = 'Saving...';
                    saveBtn.disabled = true;
                    saveBtn.classList.add('loading');
                }
                
                let response;
                let url;
                let method;
                
                if (isAddMode) {
                    // Create new item
                    console.log('ðŸ†• Creating new item with data:', formattedData);
                    url = '/api/memories';
                    method = 'POST';
                } else {
                    // Update existing item - ENSURE ID IS PROPERLY PASSED
                    const itemId = currentEditItem.id;
                    console.log(`ðŸ”„ Updating item ${itemId} with data:`, formattedData);
                    
                    if (!itemId) {
                        throw new Error('No item ID found for update');
                    }
                    
                    url = `/api/memories/${itemId}`;
                    method = 'PUT';
                }
                
                console.log(`ðŸ“¡ Making ${method} request to ${url}`);
                
                response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(formattedData)
                });
                
                console.log('ðŸ“¡ Response status:', response.status);
                console.log('ðŸ“¡ Response headers:', Object.fromEntries(response.headers.entries()));
                
                // ENHANCED: Better error handling
                if (response.ok) {
                    const result = await response.json();
                    console.log('âœ… Save successful:', result);
                    
                    if (isAddMode) {
                        showToast('âœ… Item created successfully!', 'success');
                        // Add to feedItems array for immediate UI update
                        feedItems.unshift(result);
                    } else {
                        // Update the item in feedItems array
                        const itemIndex = feedItems.findIndex(item => item.id === currentEditItem.id);
                        if (itemIndex !== -1) {
                            feedItems[itemIndex] = { ...feedItems[itemIndex], ...result };
                        }
                        showToast('âœ… Changes saved successfully!', 'success');
                    }
                    
                    closeEdit();
                    await refreshFeed(); // Refresh to show changes
                } else {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: `HTTP ${response.status} ${response.statusText}` };
                    }
                    
                    console.error('âŒ Save failed:', errorData);
                    console.error('âŒ Response status:', response.status);
                    
                    // Show specific error information
                    if (response.status === 404) {
                        showToast('âŒ Item not found - it may have been deleted', 'error');
                    } else if (response.status === 400) {
                        showToast(`âŒ ${errorData.error || 'Invalid data provided'}`, 'error');
                    } else if (response.status === 403) {
                        showToast('âŒ Access denied - please log in again', 'error');
                    } else {
                        showToast(`âŒ ${errorData.error || 'Failed to save changes'}`, 'error');
                    }
                    
                    // Log debug information
                    if (debugMode || process.env.NODE_ENV === 'development') {
                        console.log('ðŸ› Debug information:');
                        console.log('  - Item ID:', currentEditItem?.id);
                        console.log('  - Formatted data:', formattedData);
                        console.log('  - Response:', errorData);
                    }
                }
                
            } catch (error) {
                console.error('âŒ Network/JS error during save:', error);
                showToast('âŒ Network error - please check your connection and try again', 'error');
                
                // Additional debugging for network errors
                console.error('ðŸ› Error details:', {
                    message: error.message,
                    stack: error.stack,
                    currentEditItem: currentEditItem?.id,
                    isAddMode: isAddMode
                });
            } finally {
                // Always restore button state
                if (saveBtn) {
                    saveBtn.textContent = originalText || 'Save Changes';
                    saveBtn.disabled = false;
                    saveBtn.classList.remove('loading');
                }
            }
        }

        // ===== AI CHAT FUNCTIONS =====
        
        // Build comprehensive context for AI to understand the item
        function buildItemContext(item) {
            const context = {
                itemId: item.id,
                type: item.type || 'general',
                currentStatus: item.status || 'active',
                priority: item.priority || 3,
                content: item.content || '',
                contentShort: item.content_short || '',
                
                // Time-related fields
                created: item.created_at ? new Date(item.created_at).toLocaleDateString() : 'Unknown',
                due: item.due ? new Date(item.due).toLocaleDateString() : 'Not set',
                completedDate: item.completed_date ? new Date(item.completed_date).toLocaleDateString() : null,
                modified: item.modified ? new Date(item.modified).toLocaleDateString() : null,
                
                // Additional metadata
                stage: item.stage || null,
                routineType: item.routine_type || null,
                goalType: item.goal_type || null,
                frequency: item.frequency || null,
                location: item.location || null,
                mood: item.mood || null,
                trigger: item.trigger || null,
                performanceStreak: item.performance_streak || 0,
                requiredTime: item.required_time_minutes || null,
                notes: item.notes || '',
                successCriteria: item.success_criteria || ''
            };
            
            // Build contextual prompt with today's date
            const today = new Date();
            const todayStr = today.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            
            let contextPrompt = `You are MindOS AI assistant, helping with a specific ${context.type} item.

TODAY'S DATE: ${todayStr}
CURRENT TIME: ${today.toLocaleTimeString()}

ITEM CONTEXT:
- ID: ${context.itemId}
- Type: ${context.type}
- Status: ${context.currentStatus}
- Priority: ${context.priority} (1=Low, 5=Critical)
- Content: "${context.content}"
- Created: ${context.created}
`;

            // Add relevant fields based on type
            if (context.due !== 'Not set') contextPrompt += `- Due: ${context.due}\n`;
            if (context.completedDate) contextPrompt += `- Completed: ${context.completedDate}\n`;
            if (context.stage) contextPrompt += `- Stage: ${context.stage}\n`;
            if (context.frequency) contextPrompt += `- Frequency: ${context.frequency}\n`;
            if (context.location) contextPrompt += `- Location: ${context.location}\n`;
            if (context.performanceStreak > 0) contextPrompt += `- Performance Streak: ${context.performanceStreak} days\n`;
            if (context.requiredTime) contextPrompt += `- Required Time: ${context.requiredTime} minutes\n`;
            if (context.notes) contextPrompt += `- Notes: ${context.notes}\n`;
            if (context.successCriteria) contextPrompt += `- Success Criteria: ${context.successCriteria}\n`;
            
            // Type-specific context
            if (context.type === 'routine' && context.routineType) {
                contextPrompt += `- Routine Type: ${context.routineType}\n`;
            }
            if (context.type === 'goal' && context.goalType) {
                contextPrompt += `- Goal Type: ${context.goalType}\n`;
            }
            
            contextPrompt += `
CAPABILITIES:
You can help the user by:
1. Updating any field of this item (content, status, priority, due date, etc.)
2. Marking as complete or changing status
3. Adding or modifying notes
4. Setting or changing due dates (you know today is ${todayStr})
5. Rescheduling items - calculate new dates based on today's date
6. Adjusting priority
7. Providing advice specific to this ${context.type}
8. Breaking down complex items into subtasks
9. For recurring items (frequency: ${context.frequency || 'none'}), helping set next occurrence
10. Suggesting improvements based on the item's context

IMPORTANT CONSTRAINTS:
- You can ONLY discuss and modify THIS specific item (ID: ${context.itemId})
- You cannot access or modify other items in the user's list
- All suggestions should be relevant to this specific ${context.type}
- When the user asks to update something, provide clear confirmation of what will be changed
- If the user asks about unrelated topics, politely redirect to this specific item

AVAILABLE FIELDS YOU CAN MODIFY:
- content, type, status (active/completed/paused/archived)
- priority (1-5), due date, notes, stage
- location, frequency, required_time_minutes
- success_criteria, mood, trigger
${context.type === 'routine' ? '- routine_type (morning/evening/daily/weekly/workout/health)' : ''}
${context.type === 'goal' ? '- goal_type (personal/professional/health/financial/learning)' : ''}

Please be helpful, contextual, and focused on this specific item.`;
            
            return contextPrompt;
        }

        // ===== AI COMMENT BUBBLE INTERFACE =====
        
        // Toggle AI bubble for specific item
        function toggleAIBubble(itemId) {
            const existingBubble = document.querySelector(`.ai-comment-bubble[data-item-id="${itemId}"]`);
            if (existingBubble) {
                closeAIBubble(itemId);
            } else {
                openAIBubble(itemId);
            }
        }
        
        // Open AI bubble for specific item
        async function openAIBubble(itemId) {
            // Ensure proper type comparison (handle both string and number IDs)
            const item = feedItems.find(i => i.id == itemId);
            if (!item) {
                showToast('Item not found', 'error');
                return;
            }
            
            currentAIItem = item;
            
            // Load chat history
            if (item.ai_chat_history) {
                try {
                    aiChatHistory = JSON.parse(item.ai_chat_history);
                } catch (e) {
                    aiChatHistory = [];
                }
            } else {
                aiChatHistory = [];
            }
            
            // Create bubble HTML
            const card = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!card) return;
            
            const bubble = document.createElement('div');
            bubble.className = 'ai-comment-bubble';
            bubble.dataset.itemId = itemId;
            bubble.innerHTML = `
                <div class="bubble-header" onmousedown="startDragBubble(event, ${itemId})">
                    <div class="bubble-header-title">
                        <div class="brain-icon">
                            <i class="fas fa-brain"></i>
                        </div>
                        <span>AI Assistant</span>
                    </div>
                    <div class="bubble-actions">
                        <button class="bubble-action-btn pin-btn" onclick="togglePinnedPanel()" title="View Pinned Insights">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                        <button class="bubble-action-btn" onclick="minimizeBubble(${itemId})" title="Minimize">
                            <i class="fas fa-minus"></i>
                        </button>
                        <button class="bubble-action-btn" onclick="closeAIBubble(${itemId})" title="Close">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="bubble-quick-actions" id="quickActions-${itemId}">
                    <!-- Quick actions will be populated based on item type -->
                </div>
                <div class="bubble-messages" id="bubbleMessages-${itemId}">
                    <!-- Messages will appear here -->
                </div>
                <div class="bubble-input-container">
                    <div class="bubble-input-wrapper">
                        <textarea class="bubble-input" id="bubbleInput-${itemId}" 
                            placeholder="Ask about this ${item.type || 'item'}..." 
                            onkeydown="handleBubbleKeydown(event, ${itemId})"
                            oninput="autoResizeBubbleInput(this)"></textarea>
                        <button class="bubble-send" id="bubbleSend-${itemId}" 
                            onclick="sendBubbleMessage(${itemId})">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            `;
            
            // Position bubble relative to card
            card.appendChild(bubble);
            
            // Store bubble reference
            activeBubbles.set(itemId, bubble);
            
            // Populate quick actions based on item type
            populateQuickActions(itemId, item);
            
            // Load existing chat history
            if (aiChatHistory.length > 0) {
                aiChatHistory.forEach(msg => {
                    if (msg.role !== 'system') {
                        addBubbleMessage(itemId, msg.role, msg.content, false);
                    }
                });
            } else {
                // Add welcome message with context
                const today = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                let welcomeMessage = `Hi! I'm here to help you with this ${item.type || 'item'}.\n\n`;
                
                // Add status-specific suggestions
                if (item.status === 'active') {
                    welcomeMessage += `I can help you:\n`;
                    welcomeMessage += `â€¢ Mark it as complete\n`;
                    welcomeMessage += `â€¢ Reschedule it (today is ${today})\n`;
                    if (item.frequency) {
                        welcomeMessage += `â€¢ Adjust the frequency (currently: ${item.frequency})\n`;
                    }
                    welcomeMessage += `â€¢ Break it into smaller tasks\n`;
                    welcomeMessage += `â€¢ Add notes or update details\n`;
                }
                
                if (item.due) {
                    const dueDate = new Date(item.due);
                    const daysUntilDue = Math.ceil((dueDate - new Date()) / (1000 * 60 * 60 * 24));
                    if (daysUntilDue < 0) {
                        welcomeMessage += `\nâš ï¸ This item is ${Math.abs(daysUntilDue)} days overdue!`;
                    } else if (daysUntilDue === 0) {
                        welcomeMessage += `\nâ° This item is due today!`;
                    } else if (daysUntilDue <= 3) {
                        welcomeMessage += `\nâ° This item is due in ${daysUntilDue} days.`;
                    }
                }
                
                welcomeMessage += `\n\nWhat would you like to do?`;
                addBubbleMessage(itemId, 'assistant', welcomeMessage, true);
            }
            
            // Show bubble with animation
            setTimeout(() => bubble.classList.add('show'), 10);
            
            // Focus input
            setTimeout(() => {
                const input = document.getElementById(`bubbleInput-${itemId}`);
                if (input) input.focus();
            }, 300);
        }
        
        // Close AI bubble
        function closeAIBubble(itemId) {
            const bubble = activeBubbles.get(itemId);
            if (bubble) {
                bubble.classList.remove('show');
                setTimeout(() => {
                    bubble.remove();
                    activeBubbles.delete(itemId);
                }, 300);
            }
            if (currentAIItem && currentAIItem.id === itemId) {
                currentAIItem = null;
            }
        }
        
        // Minimize/maximize bubble
        function minimizeBubble(itemId) {
            const bubble = activeBubbles.get(itemId);
            if (bubble) {
                bubble.classList.toggle('minimized');
            }
        }
        
        // Populate quick actions based on item type
        function populateQuickActions(itemId, item) {
            const container = document.getElementById(`quickActions-${itemId}`);
            if (!container) return;
            
            const quickActions = getQuickActionsForType(item.type, item.status, item);
            
            container.innerHTML = quickActions.map(action => 
                `<button class="quick-action-chip ${action.suggested ? 'suggested' : ''}" 
                    onclick="sendQuickAction(${itemId}, '${action.text.replace(/'/g, "\\'")}')"
                    title="${action.text}">
                    ${action.icon ? `<i class="fas fa-${action.icon}"></i> ` : ''}${action.label}
                </button>`
            ).join('');
        }
        
        // Get appropriate quick actions based on item type
        function getQuickActionsForType(type, status, item) {
            const baseActions = [
                { label: 'Help me start', text: 'How should I begin working on this?', icon: 'play' },
                { label: 'Break it down', text: 'Can you break this down into smaller steps?', icon: 'list' }
            ];
            
            // Add rescheduling options if item has a due date or is overdue
            if (item && item.due) {
                const dueDate = new Date(item.due);
                const today = new Date();
                const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                
                if (daysUntilDue < 0) {
                    baseActions.unshift({ 
                        label: 'Reschedule', 
                        text: 'This is overdue. Please reschedule it to a new date.', 
                        icon: 'calendar-alt',
                        suggested: true 
                    });
                }
            }
            
            const typeSpecificActions = {
                routine: [
                    { label: 'Optimize timing', text: 'What\'s the best time to do this routine?', icon: 'clock' },
                    { label: 'Track progress', text: 'Help me track my progress with this routine', icon: 'chart-line', suggested: true }
                ],
                goal: [
                    { label: 'Set milestones', text: 'Help me set milestones for this goal', icon: 'flag' },
                    { label: 'Success metrics', text: 'What metrics should I track for this goal?', icon: 'chart-bar', suggested: true }
                ],
                task: [
                    { label: 'Time estimate', text: 'How long will this task take?', icon: 'hourglass' },
                    { label: 'Prerequisites', text: 'What do I need before starting this?', icon: 'tasks' }
                ]
            };
            
            if (status === 'active') {
                baseActions.push({ label: 'Mark complete', text: 'I\'ve completed this item', icon: 'check', suggested: true });
                
                // Add common rescheduling options
                baseActions.push(
                    { label: 'Do tomorrow', text: 'Reschedule this to tomorrow', icon: 'calendar-day' },
                    { label: 'Next week', text: 'Reschedule this to next week', icon: 'calendar-week' }
                );
            }
            
            return [...baseActions, ...(typeSpecificActions[type] || [])];
        }
        
        // Send quick action
        function sendQuickAction(itemId, text) {
            const input = document.getElementById(`bubbleInput-${itemId}`);
            if (input) {
                input.value = text;
                sendBubbleMessage(itemId);
            }
        }
        
        // Add message to bubble
        function addBubbleMessage(itemId, role, content, updateHistory = true) {
            const container = document.getElementById(`bubbleMessages-${itemId}`);
            if (!container) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `bubble-message ${role}`;
            
            let avatarIcon = role === 'user' ? 'fa-user' : 'fa-brain';
            
            // Format content with line breaks
            const formattedContent = content.replace(/\n/g, '<br>');
            
            // Create a unique ID for this message
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            messageDiv.innerHTML = `
                <div class="bubble-message-avatar">
                    <i class="fas ${avatarIcon}"></i>
                </div>
                <div class="bubble-message-content" id="${messageId}">
                    ${formattedContent}
                    ${role === 'assistant' ? `
                        <button class="pin-insight-btn" data-message-id="${messageId}"
                            style="margin-left: 8px; background: none; border: none; color: #667eea; cursor: pointer; font-size: 0.8rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">
                            <i class="fas fa-thumbtack"></i>
                        </button>` : ''}
                </div>
            `;
            
            // Add to DOM first
            container.appendChild(messageDiv);
            
            // Then add event listener for pin button if it's an assistant message
            if (role === 'assistant') {
                const pinBtn = messageDiv.querySelector('.pin-insight-btn');
                if (pinBtn) {
                    pinBtn.addEventListener('click', function() {
                        // Get the actual content from the message element, not from the inline parameter
                        const messageContent = document.getElementById(messageId);
                        if (messageContent) {
                            // Get text content without HTML tags and without the pin button
                            const textContent = messageContent.cloneNode(true);
                            // Remove the pin button from the cloned content
                            const pinBtnInClone = textContent.querySelector('.pin-insight-btn');
                            if (pinBtnInClone) pinBtnInClone.remove();
                            // Get the clean text without HTML tags
                            const cleanText = textContent.innerText || textContent.textContent;
                            pinInsight(cleanText.trim());
                        }
                    });
                }
            }
            
            container.scrollTop = container.scrollHeight;
            
            // Update history if needed
            if (updateHistory && role !== 'system') {
                const message = { role, content, timestamp: new Date().toISOString() };
                aiChatHistory.push(message);
            }
        }
        
        // Handle bubble input keydown
        function handleBubbleKeydown(event, itemId) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendBubbleMessage(itemId);
            }
        }
        
        // Auto-resize bubble input
        function autoResizeBubbleInput(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 80) + 'px';
        }
        
        // Send message in bubble
        async function sendBubbleMessage(itemId) {
            const input = document.getElementById(`bubbleInput-${itemId}`);
            const sendBtn = document.getElementById(`bubbleSend-${itemId}`);
            const message = input.value.trim();
            
            if (!message) return;
            
            // Ensure proper type comparison
            const item = feedItems.find(i => i.id == itemId);
            if (!item) return;
            
            currentAIItem = item;
            
            // Add user message
            addBubbleMessage(itemId, 'user', message);
            input.value = '';
            
            // Reset input height
            input.style.height = 'auto';
            
            // Show loading
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            
            try {
                const itemContext = buildItemContext(item);
                
                // Debug logging
                console.log('ðŸ” Sending bubble message:', {
                    itemId: item.id,
                    message: message,
                    historyLength: aiChatHistory.length
                });
                
                // Prepare messages array with system message first
                const messagesForAPI = [
                    { role: 'system', content: itemContext },
                    ...aiChatHistory
                ];
                
                const response = await fetch('/api/claude/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        itemId: item.id,
                        itemContext: itemContext,
                        messages: messagesForAPI
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const aiResponse = data.content[0].text;
                    
                    addBubbleMessage(itemId, 'assistant', aiResponse);
                    
                    // Handle field updates if suggested
                    if (data.has_updates && data.field_updates) {
                        await handleAIFieldUpdates(data.field_updates);
                    }
                    
                    // Save chat history
                    await saveChatHistory();
                    
                } else {
                    const errorData = await response.json();
                    console.error('Bubble API error:', errorData);
                    const errorMessage = errorData.details || errorData.error || 'Unknown error';
                    addBubbleMessage(itemId, 'assistant', `Sorry, I encountered an error: ${errorMessage}. Please try again.`);
                }
                
            } catch (error) {
                console.error('Bubble chat error:', error);
                addBubbleMessage(itemId, 'assistant', 'Sorry, I encountered an error. Please try again.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
            }
        }
        
        // Bubble dragging functionality
        let draggedBubble = null;
        let dragOffset = { x: 0, y: 0 };
        
        function startDragBubble(event, itemId) {
            const bubble = activeBubbles.get(itemId);
            if (!bubble) return;
            
            draggedBubble = bubble;
            const rect = bubble.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left;
            dragOffset.y = event.clientY - rect.top;
            
            document.addEventListener('mousemove', dragBubble);
            document.addEventListener('mouseup', stopDragBubble);
        }
        
        function dragBubble(event) {
            if (!draggedBubble) return;
            
            const x = event.clientX - dragOffset.x;
            const y = event.clientY - dragOffset.y;
            
            draggedBubble.style.left = `${x}px`;
            draggedBubble.style.top = `${y}px`;
            draggedBubble.style.right = 'auto';
            draggedBubble.style.bottom = 'auto';
            draggedBubble.style.position = 'fixed';
        }
        
        function stopDragBubble() {
            draggedBubble = null;
            document.removeEventListener('mousemove', dragBubble);
            document.removeEventListener('mouseup', stopDragBubble);
        }
        
        // Pin insight functionality with smart content extraction
        function pinInsight(text) {
            if (!text) return;
            
            // Extract valuable content by removing common intro/outro patterns
            const extractValuableContent = (fullText) => {
                // Split into lines for processing
                let lines = fullText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                
                // Patterns to skip entirely
                const skipPatterns = [
                    /^(based on|according to|looking at|regarding|about) (the|your|this) (task|item|context|information)/i,
                    /^(here's|here are|these are|this is) (what|the|some)/i,
                    /^would you like (me )?to/i,
                    /^(also|additionally|furthermore|moreover),? (it might|you might|I can|I could)/i,
                    /^(I can|I could|I'll|I will) (help|assist|update|add|create)/i,
                    /^(let me know|please let me know|feel free to)/i,
                    /^is there anything else/i,
                    /^(do you|would you) (want|need|like)/i,
                    /^any (other|additional|further) (questions|information|details)/i,
                    /^if you (need|want|have|would like)/i,
                    /^that (should|would|will) (help|be|cover)/i,
                ];
                
                // Outro phrases that indicate the end of valuable content
                const outroIndicators = [
                    /would you like me to/i,
                    /let me know if/i,
                    /I can (help|update|add|create)/i,
                    /any (questions|thoughts|concerns)/i,
                    /is there anything/i,
                    /feel free to/i,
                    /if you (need|want|have any)/i
                ];
                
                // Find where the valuable content ends
                let endIndex = lines.length;
                for (let i = 0; i < lines.length; i++) {
                    if (outroIndicators.some(pattern => pattern.test(lines[i]))) {
                        endIndex = i;
                        break;
                    }
                }
                
                // Filter out intro lines and take only content before outro
                let valuableLines = lines.slice(0, endIndex).filter(line => {
                    return !skipPatterns.some(pattern => pattern.test(line));
                });
                
                // Additional processing: look for lists or structured content
                let processedContent = [];
                let inList = false;
                let currentList = [];
                
                for (let line of valuableLines) {
                    // Check if this is a list item
                    const listItemMatch = line.match(/^(\d+\.|[-â€¢*]|\w\))\s+(.+)/);
                    
                    if (listItemMatch) {
                        inList = true;
                        currentList.push(line);
                    } else if (inList && line.length > 0 && !line.endsWith(':')) {
                        // Continuation of list item
                        currentList[currentList.length - 1] += ' ' + line;
                    } else {
                        // Not a list item
                        if (inList && currentList.length > 0) {
                            processedContent.push(...currentList);
                            currentList = [];
                            inList = false;
                        }
                        // Only add non-empty lines that aren't just headers for empty sections
                        if (line.length > 0 && !line.endsWith(':')) {
                            processedContent.push(line);
                        } else if (line.endsWith(':') && valuableLines.indexOf(line) < valuableLines.length - 1) {
                            // Keep headers only if they have content after them
                            processedContent.push(line);
                        }
                    }
                }
                
                // Add any remaining list items
                if (currentList.length > 0) {
                    processedContent.push(...currentList);
                }
                
                // Join and clean up
                let extracted = processedContent.join('\n').trim();
                
                // If we've removed everything, it probably wasn't worth pinning
                if (extracted.length === 0 || extracted.split('\n').length < 2) {
                    return null;
                }
                
                return extracted;
            };
            
            // Extract valuable content
            const valuableContent = extractValuableContent(text);
            
            if (!valuableContent) {
                showToast('No substantial content to pin', 'info');
                return;
            }
            
            // Check for duplicates
            if (pinnedInsights.some(i => i.text === valuableContent)) {
                showToast('This insight is already pinned', 'info');
                return;
            }
            
            pinnedInsights.push({
                id: Date.now(),
                text: valuableContent,
                fullText: text, // Keep original for reference
                timestamp: new Date().toISOString(),
                itemId: currentAIItem?.id
            });
            
            showToast('Insight pinned!', 'success');
            updatePinnedPanel();
        }
        
        // Toggle pinned insights panel
        function togglePinnedPanel() {
            let panel = document.getElementById('pinnedInsightsPanel');
            
            if (!panel) {
                panel = document.createElement('div');
                panel.id = 'pinnedInsightsPanel';
                panel.className = 'pinned-insights-panel';
                panel.innerHTML = `
                    <div class="pinned-insights-header">
                        <h3><i class="fas fa-thumbtack"></i> Pinned Insights</h3>
                        <button class="bubble-action-btn" onclick="closePinnedPanel()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="pinned-insights-list" id="pinnedInsightsList">
                        <!-- Pinned insights will appear here -->
                    </div>
                `;
                document.body.appendChild(panel);
            }
            
            panel.classList.toggle('show');
            if (panel.classList.contains('show')) {
                updatePinnedPanel();
            }
        }
        
        function closePinnedPanel() {
            const panel = document.getElementById('pinnedInsightsPanel');
            if (panel) {
                panel.classList.remove('show');
            }
        }
        
        function updatePinnedPanel() {
            const list = document.getElementById('pinnedInsightsList');
            if (!list) return;
            
            if (pinnedInsights.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #888; padding: 2rem;">No pinned insights yet</p>';
            } else {
                list.innerHTML = pinnedInsights.map(insight => `
                    <div class="pinned-insight">
                        <button class="pinned-insight-remove" onclick="removePinnedInsight(${insight.id})">
                            <i class="fas fa-times"></i>
                        </button>
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.3rem;">
                            ${new Date(insight.timestamp).toLocaleString()}
                        </div>
                        ${insight.text}
                    </div>
                `).join('');
            }
        }
        
        function removePinnedInsight(id) {
            pinnedInsights = pinnedInsights.filter(i => i.id !== id);
            updatePinnedPanel();
        }
        
        // Generate a context-aware welcome message
        function generateWelcomeMessage(item) {
            let message = `Hi! I'm here to help you with this ${item.type || 'item'}: "${item.content_short || item.content}"\n\n`;
            
            // Add status-specific suggestions
            if (item.status === 'active') {
                message += `I can help you:\nâ€¢ Mark it as complete\nâ€¢ Set or update the due date\nâ€¢ Break it into smaller tasks\nâ€¢ Add notes or details\n`;
            } else if (item.status === 'completed') {
                message += `This item is completed! I can help you:\nâ€¢ Reactivate it\nâ€¢ Create a similar item\nâ€¢ Add completion notes\n`;
            }
            
            // Add type-specific suggestions
            if (item.type === 'routine') {
                message += `â€¢ Adjust the frequency (currently: ${item.frequency || 'not set'})\nâ€¢ Track your streak (currently: ${item.performance_streak || 0} days)\n`;
            } else if (item.type === 'goal') {
                message += `â€¢ Update progress towards the goal\nâ€¢ Set milestones\nâ€¢ Adjust the target date\n`;
            }
            
            // Add priority-specific note
            if (item.priority >= 4) {
                message += `\nâš¡ This is a high priority item. Would you like help planning immediate next steps?`;
            }
            
            message += `\nWhat would you like to do?`;
            return message;
        }

        // Keep compatibility with old interface
        function openAIChat(itemId) {
            console.warn('openAIChat is deprecated, using bubble interface');
            openAIBubble(itemId);
        }
        
        function closeAIChat() {
            // Close all bubbles
            activeBubbles.forEach((bubble, itemId) => {
                closeAIBubble(itemId);
            });
        }

        function renderAIChatHistory() {
            const container = document.getElementById('aiChatMessages');
            container.innerHTML = '';
            
            aiChatHistory.forEach(message => {
                addAIMessageToDOM(message.role, message.content);
            });
            
            scrollChatToBottom();
        }

        function addAIMessage(role, content) {
            const message = { role, content, timestamp: new Date().toISOString() };
            aiChatHistory.push(message);
            addAIMessageToDOM(role, content);
            scrollChatToBottom();
        }

        function addAIMessageToDOM(role, content) {
            const container = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${role}`;
            
            let avatarIcon = 'fas fa-brain';
            if (role === 'user') {
                avatarIcon = 'fas fa-user';
            } else if (role === 'system') {
                avatarIcon = 'fas fa-cog';
                messageDiv.style.background = 'rgba(255, 193, 7, 0.1)';
                messageDiv.style.borderLeft = '3px solid #ffc107';
            }
            
            // Handle newlines in content
            const formattedContent = content.replace(/\n/g, '<br>');
            
            messageDiv.innerHTML = `
                <div class="ai-message-avatar">
                    <i class="${avatarIcon}"></i>
                </div>
                <div class="ai-message-content">${formattedContent}</div>
            `;
            
            container.appendChild(messageDiv);
        }

        function scrollChatToBottom() {
            const container = document.getElementById('aiChatMessages');
            container.scrollTop = container.scrollHeight;
        }

        async function sendAIMessage() {
            const input = document.getElementById('aiChatInput');
            const sendBtn = document.getElementById('aiChatSend');
            const message = input.value.trim();
            
            if (!message || !currentAIItem) return;
            
            // Add user message
            addAIMessage('user', message);
            input.value = '';
            
            // Show loading
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            
            try {
                // Build comprehensive context for the AI
                const itemContext = buildItemContext(currentAIItem);
                
                // Send to Claude API for processing with enhanced endpoint
                const response = await fetch('/api/claude/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        itemId: currentAIItem.id,
                        itemContext: itemContext,
                        messages: [
                            ...aiChatHistory,
                            { role: 'user', content: message }
                        ]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add AI response
                    const aiResponse = data.content[0].text;
                    addAIMessage('assistant', aiResponse);
                    
                    // Check if AI suggested field updates
                    if (data.has_updates && data.field_updates) {
                        await handleAIFieldUpdates(data.field_updates);
                    }
                    
                    // Save chat history to item
                    await saveChatHistory();
                    
                } else {
                    const errorData = await response.json();
                    console.error('AI Chat API error:', errorData);
                    addAIMessage('assistant', `Sorry, I encountered an error: ${errorData.details || errorData.error || 'Unknown error'}. Please try again.`);
                }
                
            } catch (error) {
                console.error('AI Chat error:', error);
                addAIMessage('assistant', 'Sorry, I encountered an error. Please try again.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
            }
        }

        // Handle AI-suggested field updates
        async function handleAIFieldUpdates(fieldUpdates) {
            console.log('ðŸ¤– AI suggested field updates:', fieldUpdates);
            
            const { suggested_updates, validated_updates, reasoning } = fieldUpdates;
            const updates = validated_updates || suggested_updates;
            
            if (!updates || Object.keys(updates).length === 0) return;
            
            // Show confirmation dialog
            const updatesList = Object.entries(updates)
                .map(([field, value]) => `â€¢ ${field}: ${value}`)
                .join('\n');
            
            const confirmMessage = `AI suggested these updates:\n\n${updatesList}\n\nReason: ${reasoning}\n\nApply these changes?`;
            
            if (confirm(confirmMessage)) {
                try {
                    // Apply the updates
                    const response = await fetch(`/api/memories/${currentAIItem.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(updates)
                    });
                    
                    if (response.ok) {
                        const updatedItem = await response.json();
                        
                        // Update local item
                        Object.assign(currentAIItem, updatedItem);
                        
                        // Update in feedItems array
                        const itemIndex = feedItems.findIndex(item => item.id === currentAIItem.id);
                        if (itemIndex !== -1) {
                            feedItems[itemIndex] = { ...feedItems[itemIndex], ...updatedItem };
                        }
                        
                        // Update UI if the item is visible
                        updateItemInUI(currentAIItem.id, updatedItem);
                        
                        // Add confirmation message to chat
                        addAIMessage('system', `âœ… Fields updated successfully:\n${updatesList}`);
                        
                        // If status changed to completed, handle removal from feed
                        if (updates.status === 'completed') {
                            setTimeout(() => {
                                const card = document.querySelector(`[data-item-id="${currentAIItem.id}"]`);
                                if (card) {
                                    card.style.transition = 'opacity 0.3s ease-out';
                                    card.style.opacity = '0';
                                    setTimeout(() => card.remove(), 300);
                                }
                            }, 1000);
                        }
                        
                    } else {
                        addAIMessage('system', 'âŒ Failed to apply updates. Please try again.');
                    }
                } catch (error) {
                    console.error('Error applying AI updates:', error);
                    addAIMessage('system', 'âŒ Error applying updates: ' + error.message);
                }
            } else {
                addAIMessage('system', 'â„¹ï¸ Updates cancelled by user.');
            }
        }
        
        // Update item in UI after AI changes
        function updateItemInUI(itemId, updatedData) {
            const card = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!card) return;
            
            // Update visible content
            const titleEl = card.querySelector('.card-title');
            if (titleEl && updatedData.content) {
                titleEl.textContent = updatedData.content_short || updatedData.content;
            }
            
            // Update type badge
            const typeEl = card.querySelector('.type-badge');
            if (typeEl && updatedData.type) {
                typeEl.textContent = updatedData.type;
                typeEl.className = `type-badge type-${updatedData.type}`;
            }
            
            // Update priority indicator
            const cardElement = card.querySelector('.feed-card');
            if (cardElement && updatedData.priority) {
                cardElement.setAttribute('data-priority', updatedData.priority);
            }
            
            // Update metadata
            const metaEl = card.querySelector('.card-meta');
            if (metaEl) {
                const priorityLabels = {1: 'Low', 2: 'Medium', 3: 'Normal', 4: 'High', 5: 'Critical'};
                let metaText = `Priority: ${priorityLabels[updatedData.priority] || 'Normal'}`;
                if (updatedData.due) {
                    metaText += ` â€¢ Due: ${new Date(updatedData.due).toLocaleDateString()}`;
                }
                metaEl.textContent = metaText;
            }
        }

        async function saveChatHistory() {
            try {
                await fetch(`/api/memories/${currentAIItem.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        ai_chat_history: JSON.stringify(aiChatHistory)
                    })
                });
            } catch (error) {
                console.error('Error saving chat history:', error);
            }
        }

        // Auto-resize chat input
        document.getElementById('aiChatInput').addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        });

        // Send message on Enter (but allow Shift+Enter for new lines)
        document.getElementById('aiChatInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendAIMessage();
            }
        });

        // Social Media Actions
        async function toggleComplete(itemId) {
            try {
                // Use == for type-flexible comparison
                const item = feedItems.find(i => i.id == itemId);
                if (!item) {
                    console.error('Item not found:', itemId);
                    showToast('Item not found', 'error');
                    return;
                }
                
                const isCompleted = item.status === 'completed';
                const newStatus = isCompleted ? 'active' : 'completed';
                
                const updateData = { status: newStatus };
                
                if (newStatus === 'completed' && databaseSchema?.memoriesTableColumns) {
                    const today = new Date().toISOString().split('T')[0];
                    
                    if (databaseSchema.memoriesTableColumns.includes('completed_date')) {
                        updateData.completed_date = today;
                    }
                    if (databaseSchema.memoriesTableColumns.includes('completed')) {
                        updateData.completed = today;
                    }
                    // Don't send modified - server handles this automatically
                }
                
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (response.ok) {
                    const updatedItem = await response.json();
                    
                    // Update the local item with server response
                    Object.assign(item, updatedItem);
                    
                    if (newStatus === 'completed') {
                        // Remove the item from the feed when completed
                        const card = document.querySelector(`[data-item-id="${itemId}"]`);
                        if (card) {
                            // Animate removal
                            card.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                            card.style.opacity = '0';
                            card.style.transform = 'translateX(100%)';
                            
                            setTimeout(() => {
                                card.remove();
                                // Remove from feedItems array
                                feedItems = feedItems.filter(i => i.id !== itemId);
                                // Update counts
                                document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
                                document.getElementById('totalItemsCount').textContent = feedItems.length;
                            }, 300);
                        }
                        
                        showToast(`Completed! âœ… Task removed from active list`, 'success');
                    } else {
                        // If reactivating, update the button UI
                        const card = document.querySelector(`[data-item-id="${itemId}"]`);
                        if (card) {
                            const btn = card.querySelector('.action-btn .fa-check')?.parentElement;
                            if (btn) {
                                btn.classList.remove('completed');
                            }
                        }
                        showToast('Reactivated', 'success');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Failed to toggle complete:', response.status, errorText);
                    showToast('Failed to update status', 'error');
                }
            } catch (error) {
                console.error('Error toggling complete:', error);
                showToast('Error updating status', 'error');
            }
        }

        function shareItem(itemId) {
            // Use == for type-flexible comparison
            const item = feedItems.find(i => i.id == itemId);
            if (!item) return;
            
            const text = `Check out my ${item.type}: ${item.content_short || item.content}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'MindOS Item',
                    text: text
                });
            } else {
                navigator.clipboard.writeText(text);
                showToast('Copied to clipboard!', 'success');
            }
        }

        async function deleteItem(itemId) {
            if (!confirm('Delete this item?')) return;
            
            try {
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                
                if (response.ok) {
                    // Remove from feedItems array
                    feedItems = feedItems.filter(item => item.id !== itemId);
                    
                    // Remove card from DOM
                    const card = document.querySelector(`[data-item-id="${itemId}"]`);
                    if (card) {
                        card.remove();
                    }
                    
                    document.getElementById('feedItemCount').textContent = `${feedItems.length} items in feed`;
                    document.getElementById('totalItemsCount').textContent = feedItems.length;
                    
                    showToast('Deleted', 'success');
                } else {
                    showToast('Failed to delete', 'error');
                }
            } catch (error) {
                console.error('Error deleting:', error);
                showToast('Error deleting item', 'error');
            }
        }

        // Header Actions
        async function refreshFeed() {
            const feedScroll = document.getElementById('feedScroll');
            feedScroll.innerHTML = '';
            
            await loadInitialFeed();
            showToast('Feed refreshed!', 'success');
        }

        function showProfile() {
            showToast('Profile coming soon!', 'info');
        }

        function logout() {
            localStorage.removeItem('mindos_token');
            authToken = null;
            currentUser = null;
            feedItems = [];
            
            document.getElementById('feedContainer').style.display = 'none';
            document.getElementById('loginScreen').style.display = 'flex';
            showLogin();
            
            showToast('Logged out', 'success');
        }

        // Utility Functions
        function showToast(message, type = 'info') {
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => toast.remove());
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            
            if (type === 'error') {
                toast.style.background = 'rgba(244, 67, 54, 0.9)';
            } else if (type === 'success') {
                toast.style.background = 'rgba(76, 175, 80, 0.9)';
            } else if (type === 'warning') {
                toast.style.background = 'rgba(255, 152, 0, 0.9)';
            }
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Global debug functions for testing
        window.debugEditMode = function() {
            debugMode = !debugMode;
            console.log('ðŸ› Debug mode:', debugMode ? 'ENABLED' : 'DISABLED');
            if (debugMode) {
                console.log('Use: debugEditItem(itemId) to debug a specific item');
            }
        };
        
        // Debug completion function
        window.debugCompletion = async function(itemId) {
            console.log('ðŸ” Testing completion for item:', itemId);
            
            if (!authToken) {
                console.error('âŒ Not logged in!');
                return;
            }
            
            try {
                console.log('ðŸ“¤ Sending completion request...');
                const response = await fetch(`/api/memories/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ status: 'completed' })
                });
                
                console.log('ðŸ“¥ Response status:', response.status);
                const responseText = await response.text();
                console.log('ðŸ“¥ Response:', responseText);
                
                if (response.ok) {
                    console.log('âœ… Success! Item marked as completed');
                    const data = JSON.parse(responseText);
                    console.log('Updated item:', data);
                } else {
                    console.error('âŒ Failed:', responseText);
                }
            } catch (error) {
                console.error('âŒ Error:', error);
            }
        };
        
        // List all items with IDs
        window.listItems = function() {
            console.log('ðŸ“‹ Your items:');
            feedItems.forEach((item, index) => {
                console.log(`${index + 1}. ID: ${item.id} - "${item.content_short || item.content}" (Status: ${item.status})`);
            });
            if (feedItems.length === 0) {
                console.log('No items found. Try refreshing the feed.');
            }
        };

        window.testEdit = async function(itemId) {
            console.log('ðŸ§ª Testing edit for item:', itemId);
            const item = feedItems.find(i => i.id == itemId);
            if (item) {
                console.log('Found item:', item);
                editItem(itemId);
            } else {
                console.log('Item not found. Available items:', feedItems.map(i => i.id));
            }
        };

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEdit();
                closeAIChat();
            }
            if (e.key === 'Home') {
                e.preventDefault();
                scrollToTop();
            }
        });

        // Touch/Swipe Support (simplified for continuous scroll)
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            const diff = touchStartY - touchEndY;
            
            // Only handle large swipes for special actions
            if (Math.abs(diff) > 100) {
                if (diff < -100) {
                    // Large upward swipe - go to top
                    scrollToTop();
                }
            }
        });
    </script>
</body>
</html>
